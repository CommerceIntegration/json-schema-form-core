{"version":3,"sources":["webpack:///webpack/bootstrap 72dc4632fd39a22e4991","webpack:///./src/lib/sf-path.js","webpack:///./src/lib/canonical-title-map.js","webpack:///./~/objectpath/index.js","webpack:///./src/lib/schema-defaults.js","webpack:///./src/module.js","webpack:///node_modules/browser-pack/_prelude.js","webpack:///index.js","webpack:///node_modules/component-emitter/index.js","webpack:///node_modules/native-promise-only/lib/npo.src.js","webpack:///node_modules/path-browserify/index.js","webpack:///node_modules/path-loader/index.js","webpack:///node_modules/path-loader/lib/loaders/file-browser.js","webpack:///node_modules/path-loader/lib/loaders/http.js","webpack:///node_modules/process/browser.js","webpack:///node_modules/querystring-es3/decode.js","webpack:///node_modules/querystring-es3/encode.js","webpack:///node_modules/querystring-es3/index.js","webpack:///node_modules/reduce-component/index.js","webpack:///node_modules/slash/index.js","webpack:///node_modules/superagent/lib/client.js","webpack:///node_modules/superagent/lib/is-object.js","webpack:///node_modules/superagent/lib/request-base.js","webpack:///node_modules/superagent/lib/request.js","webpack:///node_modules/uri-js/build/punycode.js","webpack:///node_modules/uri-js/build/schemes.js","webpack:///node_modules/uri-js/build/schemes/http.js","webpack:///node_modules/uri-js/build/schemes/mailto.js","webpack:///node_modules/uri-js/build/schemes/urn.js","webpack:///node_modules/uri-js/build/uri.js","webpack:///./src/lib/merge.js","webpack:///./src/lib/resolve.js","webpack:///./src/lib/select.js","webpack:///./src/lib/traverse.js","webpack:///./src/lib/validate.js","webpack:///./~/objectpath/lib/ObjectPath.js","webpack:///external \"tv4\""],"names":["name","key","separator","formName","omitNumbers","fieldKey","slice","fieldSeparator","filter","currentKey","length","join","titleMap","originalEnum","Array","isArray","canonical","forEach","value","push","Object","keys","stripNullType","type","enumToTitleMap","enm","defaultFormDefinition","schemaTypes","schema","options","rules","def","innerDefaultFormDefinition","childName","childSchema","childOptions","i","assign","stdFormObj","f","global","formDefaults","supressPropertyTitles","title","description","required","maxLength","maxlength","minLength","minlength","readOnly","readonly","minimum","exclusiveMinimum","maximum","exclusiveMaximum","validationMessage","enumNames","canonicalTitleMap","ngModelOptions","text","path","lookup","stringify","number","integer","checkbox","select","checkboxes","items","fieldset","defaultFormDef","properties","ignore","indexOf","array","arrPath","createDefaults","string","object","boolean","defaultForm","defaultSchemaTypes","globalOptions","form","Error","sfPath","schemaDefaults","merge","typeDefaults","asyncTemplates","formItems","formItemRest","idx","stdForm","idxRest","hasOwnProperty","defaultFormLookup","concat","formKeys","map","obj","element","undefined","isInside","parse","strid","attr","tabs","tab","default","template","templateUrl","jsonref","callBack","promise","Promise","resolve","reject","JsonRefs","then","res","resolved","catch","err","error","numRe","projection","valueToSet","parts","test","tmp","traverseSchema","fn","ignoreArrays","traverse","schemaObject","processorFunction","pathArray","currentPath","traverseForm","validate","valid","wrap","propName","valueWrap","tv4","validateResult"],"mappings":"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CA,qCACA,mBACA,sCACA,sCACA,oBACA,GACA;AACA,wBACA,gCACA,SACA,uBACA,CAEA,wBACA;AACA;AACA;AACA,mBACA,IAEA,+BACA,QAEA,oCACA,qBACA,OACA,iCACA,QAEA,yCACA,uBACA,MACA,QACA,QACA,IAEA,OACA,QACA,CACA,oCACA,cAEA,iCACA,uCACA,mBACA,KACA,GAEA,gCACA,oCAEA,oEACA,UACA,CACA,2BACA,CACA;uBACA,UACA,IAEA,wBACA,UACA,IAEA,kDACA,OACA,cAEA,mEACA,iBACA,eACA,qDAEA,sCACA,iBAEA,UACA;8DAEA,OACA;mEACA,YACA,iBACA,UACA,CAEA,CACA;yBAEA,UACA;4DACA,mEACA,iBACA,CACA,gCACA,eACA,MAEA,uBACA,MAEA,qDACA,gBACA,WAEA,oBACA,MACA,CACA,GAEA,OACA,WACA,CACA,uGACA,IACA,aAEA,iCACA,IACA,wBACA,uBACA,CACA;mBACA,sBACA,2BACA,KACA,CACA,MACA,UACA,IAEA,kCACA,kBACA,SAEA,wDACA,gBAEA,2BACA,iBAEA,WACA;IACA,cACA,2DAEA,6BACA,iBACA,gBACA,qBACA,WACA,CAEA,kEACA,UACA,CACA,CACA;AACA,2EACA,sBACA,wFACA,yBACA,4CACA,2BACA,8BAEA,2CACA,2BACA,8BACA,QACA,CAEA,GACA;aAEA,6DACA,0CACA,IAEA,2CACA,qBACA,WACA,aACA,gBACA,gBAEA,YACA;AACA;sBACA,2CACA,cACA,yFACA,SAEA,sBAEA,aACA;AACA;4CACA,CACA,OAEA,CACA;8BAEA,QACA;qEACA,4CACA,sDACA,iCACA,eACA,qBACA,mCACA,UAEA,CACA;wBAEA,aACA;oBAEA,SACA;oBACA,4CACA,UACA,wBACA,mCACA,2BACA,2BACA,SACA,0CACA,aACA,+CACA,WACA,WACA,uBACA,4BACA,YACA,QACA,UACA,sBACA,sBACA,2BACA,KACA,GACA,QACA,uDACA,oEACA,wCACA,UACA,wBACA,2BACA,QACA,gBACA,UACA,WACA,uBACA,4BACA,YACA,mEACA,WACA,GACA,MACA,qBACA,KACA,CACA,MACA,CACA;yDACA,kCACA,KAEA,uBACA,KACA,CACA,CAEA,YACA,wBACA,CACA;cACA,wBACA,qBAEA,sDACA,oDACA,8BAEA,SACA;wEACA,+EACA,+BACA,uCACA,gCACA,gBACA,WACA,CACA,QACA,+EACA,KAEA,uBACA,2BACA,KACA,CACA,GAEA,mDACA,6BAEA,QACA;2FACA,kCACA,KACA,CAEA,qDACA,6BAEA,gDACA,qBACA,KACA,CACA,GACA,kBACA,OACA,SAEA,SACA,UACA,CACA,4BACA,WAEA,8BACA,eAEA,qBACA,aACA,UACA,mEACA,OACA,CAEA,SACA,OACA,CACA,6BACA,6CACA,cACA,OACA,GACA,CACA,+BACA,IAEA,MACA;6BACA,eACA,eACA,WACA,SACA,UACA,qBACA,QACA,MACA,mCAGA,iBACA,MACA,CACA,uCACA,4BACA,0BACA,yDAEA,sCACA,CACA;oDACA,oDACA,mCACA,OACA,EAEA,CACA;wCAEA,eACA;SACA,2BACA,kBACA,OAGA,WACA,KACA,sBACA,kBACA,OAGA,UACA,KACA,QACA,CACA;iCACA,mBACA,MACA,GAEA,CACA;oCACA,cACA,KAEA,SACA,UACA,CACA,wCACA,aAEA,QACA,0BACA,iBACA,4DACA,iBACA,4BACA,YACA,qBACA,MACA,KAEA,SACA,MAEA,OACA,SACA,CACA,yBACA,CACA;AACA;sBACA,qBACA,iBACA,8DACA,IACA,CACA,CACA,+BACA,IACA,cAEA,+EACA,qEACA,+CACA,CACA;2FACA,EACA,6CACA,mBACA,mDACA,+BACA,OACA,MACA,EAEA,iCACA,0FACA,MACA,EACA,CACA,gCACA,IAEA,kDACA,oBACA,wDACA,gCACA,4DACA,YACA,GAEA,OACA,YACA,CACA,sBACA,CACA;qCACA,OACA,CACA,oCACA,wFACA,MACA,CACA,qCACA,qBAEA,oCACA,WACA,kCACA,SACA,MAEA,CACA;yBACA,mCACA,MAEA,CACA;gCACA,gBAEA,iCACA,yBACA,oCACA,uBACA,YACA,kCACA,wCACA,oBACA,KACA,GACA,CACA,CAEA,WACA,MACA,CACA,qCACA,gCACA,CACA;QACA,QACA,CACA;cACA,SAEA,8BACA,qBACA,6DACA,qCACA,iCACA,8CACA,qBACA,mGACA,wDACA,qBACA,qFACA,0DACA,qBACA,wFACA,2DACA,qBACA,mFACA,yCACA,qCACA,CACA;oBACA,gFAEA,8BAEA,SACA;kCAEA,qCACA,IACA,uBACA,uBACA,gDAEA,2BACA,KACA,CAEA,OACA,SACA,CAEA,oBAOA;;;;;GA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;GAWA;;;;;;;;;GAWA;;;;;;;;;GAWA;;;;;;;;;GAYA;;;;;;;;;;GAUA;;;;;;;;GAQA;;;;;;GAaA;;;;;;;;;;;GAiBA;;;;;;;;;;;;;;;GAKA;;;;GACA,qBACA,aACA,GACA,CAaA;;;;;;;;;;;;GACA,yBACA,0BACA,qBACA,yBAEA,8BACA,0BACA,oBACA,KAEA,uDACA,MACA,GACA,CAaA;;;;;;;;;;;;GACA,yBACA,0BACA,qBACA,yBAEA,8BACA,0BACA,oBACA,KAEA,6CACA,MACA,GACA,CAqBA;;;;;;;;;;;;;;;;;;;;GACA,8BACA,UAEA,GACA;+CACA,qBACA,qCAEA,CACA;gCAEA,KACA;+BACA,kCACA,0BACA,yCACA,qBACA,QAEA,+BACA,CACA;gDACA,0CACA,MAEA,0BAEA,MACA;iDACA,gDACA,MAEA,oCACA,uBACA,WAEA,CACA;AACA;kCACA,iBACA,MACA,CAEA,OACA,iBAEA,SACA,MACA,CA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,qCACA,sBAEA,2CAEA,CACA;8BACA,qBACA,6BAEA,CACA;wBAEA,SACA;0CAEA,4CACA,SACA,qBACA,kCACA,8BACA,iCAEA,iDACA,CACA;gBACA,uBAEA,mCAEA,6CACA,UAEA,CACA;uCACA,yBACA,OAEA,6CACA,sDACA,+DACA,6BACA,WAEA,CACA;MACA,mBACA,gBAEA,KAEA,CA/CA,QAgDA,UACA,CASA;;;;;;;;GACA,2BACA,aACA,KAEA,QACA,aACA,cAEA,eACA,wBACA,cACA,gCAEA,4CACA,+CACA,UAEA,aACA,4BAEA,mDACA,yBACA,cACA,kCACA,mBACA,UAEA,CACA;0BAEA,2BACA,oFACA,MACA,MACA,cACA,UACA,YACA,mBACA,qBACA,UAEA,OACA,SACA,CAiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,oCACA,WACA,QAEA,cACA,yBACA,aACA,sBAEA,wCACA,iBACA,0FACA,iBACA,sEACA,iBACA,4BACA,CACA,MACA,iBACA,uBACA,YACA,4BACA,MACA,KAEA,OACA,MAEA,OACA,OACA,CAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,oCACA,oFACA,UACA,CAWA;;;;;;;;;;GACA,yBACA,gBACA,iBACA,8BAEA,wBAEA,KACA;SAEA,0BACA,UACA,CAcA;;;;;;;;;;;;;GACA,mCACA,0BACA,iBACA,yBAEA,CACA;+EACA,KACA,CA0BA;;;;;;;;;;;;;;;;;;;;;;;;;GACA,iCACA,sBAEA,2CAEA,CACA;+CACA,qBACA,qCAEA,CACA;gCAEA,KACA;UACA,KACA,CAZA,iBAaA,4CACA,WACA,QAEA,KACA,yBACA,kBACA,YAEA,6BACA,+CACA,OAEA,CACA;mEACA,6BAEA,QACA;wBACA,cACA,WAEA,CACA;kBAEA,8EACA,8DACA,6BACA,IAEA,CACA;wCACA,sBACA,gBACA,iBACA,gBACA,WACA,6CACA,OAEA,CACA;kBACA,aACA,MACA,CACA;kBACA,aACA,CAEA,GACA;kDACA,6BAEA,QACA;2DACA,yCACA,IACA,kFAEA,MACA;kBAEA,yDACA,kBACA,6CACA,sBACA,2BAEA,KACA;kBACA,aACA,CACA,CACA,CACA,GAEA,SACA,MACA,cAEA,KAEA,SACA,UACA,CA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,wCACA,sBAEA,mBACA,wBACA,CACA;8BACA,qBACA,6BAEA,CACA;wBAEA,SACA;0CAEA,4CACA,SACA,qBACA,oBACA,iCAEA,UACA;4CACA,sDACA,WAEA,CACA;mCAEA,iCACA,6BACA,OACA,WACA,mBACA,eAEA,KACA,GAEA,SACA,UACA,CACA,+BACA,qCACA,qCACA,qCACA,iCACA,qCACA,2CACA,2BACA,2BACA,uCACA,mCACA,uCACA,6BACA,+ICr2CA,CAIA;;GACA,eACA,QAMA;;;;GACA,qBACA,qBACA,KACA,EAQA;;;;;;GACA,mBACA,kCACA,4BACA,KACA,OACA,KACA,CASA;;;;;;;GACA,qBACA,qDACA,kCACA,2DACA,SACA,UACA,MACA,EAUA;;;;;;;;GACA,yCACA,cACA,gBACA,kBACA,WAEA,OACA,iBACA,UACA,MACA,EAUA;;;;;;;;GACA,sBACA,iCACA,qCACA,wDACA,kCAEA,GACA;uBACA,iBACA,SACA,MAEA,CACA;kCACA,2BAEA,MACA;uBACA,4BACA,aACA,MAEA,CACA;GACA,uCACA,cACA,0BACA,oBACA,GACA,MACA,CACA,OACA,MACA,EAQA;;;;;;GACA,sCACA,kCACA,oCACA,iCAEA,oBACA,2BACA,8CACA,yBACA,MACA,CAEA,OACA,MACA,EAQA;;;;;;GACA,2CACA,kCACA,sCACA,GACA,EAQA;;;;;;GACA,8CACA,+BACA,OACA,8DC7JA;;;EACA,sCACA,CACA;6BACA,yFACA,gGACA,mEACA,CACA,0BAEA,mCACA,2CACA,oCACA,uDACA,EAGA,WACA;GACA,8BACA,yDACA,uCACA,OACA,aACA,2BAEA,QACA,EACA,WACA,+CACA,WACA,UACA,KACA,EAEA,CACA;iCACA,gBAEA,2BACA,SACA,aACA,mBACA,GAEA,OACA,0BACA,kBACA,cACA,WACA,KACA,KACA,OACA,KACA,MACA,cACA,GACA,wBACA,OACA,2BAEA,WACA,aACA,UACA,KACA,CAEA,GAEA,8BACA,yBACA,gBACA,8BACA,OACA,CAEA,CACA;sBACA,wBAEA,8CAEA,iCAEA,YACA,SACA,KACA,uCACA,MAEA,kBACA,qCACA,CACA,eACA,wDACA,mBAEA,IACA,mBACA,EAEA,CACA;AACA;AACA;sCACA,SACA,SACA,eACA,mBACA,KACA,KACA,cACA,UACA,IACA,KACA,yBACA,KAEA,wBACA,wBACA,wBACA,+BACA,oCACA,QACA,KACA,eACA,KACA,CACA,CACA,WACA,cACA,KACA,CAEA,sBACA,gBAEA,KACA;0BAEA,gBAEA,KACA;YACA,WACA,IAEA,IACA,0BACA,oBACA,oCACA,SACA,YACA,8DACA,0DAEA,GACA,WACA,yBACA,KACA,CACA,GACA,KACA,UACA,eACA,yBACA,iBACA,MACA,CACA,CACA,WACA,sCACA,KACA,CAEA,qBACA,UAEA,KACA;0BAEA,gBAEA,KACA;YACA,WACA,IAEA,UACA,eACA,yBACA,iBACA,MACA,CAEA,4DACA,oCACA,oBACA,yBACA,MACA,6BACA,cACA,KACA,EAEA,aACA,KACA,CAEA,8BACA,UACA,oBACA,MAEA,uBACA,cACA,gBACA,iBACA,iBACA,gBACA,GAEA,2BACA,gCACA,iBACA,kBAEA,qBACA,iBACA,iBAEA,CACA;AACA;aAEA,sBAEA,iDACA,OACA,4CACA,gDAEA,OACA;AACA;AACA;oEACA,0DACA,iBACA,kBAEA,WACA,iBACA,OACA,kBAEA,oBACA,iBACA,KAEA,UACA,QACA,yCACA,yBACA,SAEA,KACA,UACA,SACA,8BACA,kBACA,KACA,4BACA,iBACA,KAEA,GACA,WACA,iBACA,KACA,CAEA,mDACA,yBAGA,OACA;kBAEA,iBACA;uCACA,mBAGA,kEACA,iBAEA,KACA;AACA;uFACA,OACA,KAEA,yDACA,0DACA,iBACA,kBAEA,SACA,KACA,GAEA,4DACA,kDACA,0DACA,iBACA,kBAEA,QACA,KACA,GAEA,sDACA,iBAEA,KACA;wCACA,qCACA,iBACA,mBACA,4BACA,IAEA,yDACA,0DACA,iBACA,kBAEA,0CAEA,4DACA,WACA,qBACA,SACA,MACA,GACA,QACA,GAEA,wDACA,iBAEA,KACA;wCACA,qCACA,iBAEA,yDACA,0DACA,iBACA,kBAEA,2DACA,SACA,OACA,QACA,GAEA,SACA,SACA,sLCrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,6CACA,CACA;OACA,oCACA,gBACA,iBACA,gBACA,wBACA,gBACA,GACA,iBACA,gBACA,GACA,KACA,CAEA,CACA;kBACA,cACA,eACA,MACA,CAEA,OACA,OACA,CACA;AACA;AACA,GACA,6EACA,0CACA,yCACA,GACA,EACA;AACA;AACA,0BACA,kBACA,oBAEA,gEACA,oCAEA,MACA;0BACA,qBACA,4DACA,CACA,SAEA,uBACA,+CACA,IAEA,CACA;AAEA;AACA;sEACA,SACA,6BAEA,mDACA,IACA,EACA;AACA;AACA,gCACA,mCACA,sCAEA,IACA;sDACA,SACA,uBAEA,2BACA,MACA,IACA,wBACA,OACA,IAEA,2BACA,KACA,EACA;AACA,iCACA,yBACA,IACA,EACA;AACA,uBACA,gDACA,0DACA,wBACA,qBACA,0CACA,OACA,WACA,MAEA,EACA;AACA;AACA,kCACA,mCACA,iCAEA,qBACA,WACA,gCACA,oBACA,MAEA,oBACA,oBACA,kBACA,MAEA,oBACA,oCACA,GAEA,+BACA,gCAEA,mDACA,4BACA,gCACA,8BACA,iBACA,EACA,MACA,CAEA,iBACA,oDACA,kBACA,MAEA,8CAEA,0CACA,KACA,EACA,gBACA,kBACA,kCAEA,sBACA,kBACA,cAEA,kBACA,CACA;MACA,IAEA,QACA,CACA;4BACA,GAEA,aACA,IAEA,CAlBA,CAmBA,mCACA,uBACA,GACA;sCACA,2BACA,QACA,OACA,GAEA,EACA,8BACA,wBACA,GACA,EACA,qBACA,+BACA,WACA,+BACA,8BACA,IACA,OACA,KACA,CACA;AACA,6BACA,yDACA,yBACA,6BACA,8BACA,KAEA,0FCzMA;;;;;;;;;;;;;;;;;;;;;;GAEA,aAMA;;;;GACA,qBACA,cACA,mCACA,oCACA,uBACA,+GACA,4BACA,sBACA,KACA;AACA,wBACA,gCACA,SACA,uBACA,CACA,4BACA,kCACA,gEACA,GAEA,OACA,UACA,CAaA;;;;;;;;;;GAcA;;;;;;;;;;;;;IACA,4BACA,sBACA,sCAEA,uCACA,gBACA,QACA,mBACA,wCACA,QACA,CAEA,OACA,QACA,CAsEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,8CACA,sBAEA,UACA;gCACA,SACA,GAEA,CACA;iCACA,kCACA,qBACA,4DACA,qBACA,6BAEA,iCACA,2EACA,qBACA,8HACA,qBACA,6CACA,CACA,CAEA,GACA;SACA,wBACA,4CACA,sBAEA,iEACA,QACA,QACA,UACA,SACA,UACA,CACA,GACA,GACA,qBACA,2BACA,4CACA,CACA;AACA;4HACA,QACA,QACA,UACA,SACA,WACA,CACA,GACA,QACA,CACA;AACA;8EACA,IACA,CAEA,SACA,UACA,iHC9MA;;;;;;;;;;;;;;;;;;;;;;GAEA,aACA,mCACA,uDAKA;;;;GACA,iCACA,MACA,kBACA,EAGA;;GACA,8BACA,mCAEA,6BACA,IACA,uBACA,MACA,kBACA,CACA,4CChDA,8BAwBA;;;;;;;;;;;;;;;;;;;;;;GAEA,aACA,oBACA,cACA,+DACA,OAWA;;;;;;;;;;GACA,uDACA,4DACA,SACA,QAEA,0CACA,QACA,UACA,UACA,CACA;kCACA,YACA,MAEA,CACA,0BACA,SACA,UACA,WACA,oBACA,KACA,CACA,GACA,CAEA,wCACA,qCACA,mBACA,8FACA,mBACA,uHACA,wDACA,IACA,kGACA,mBACA,6CAEA,SACA,6DAEA,oCACA,IACA,oCACA,yBACA,UACA,MACA,MACA,uBACA,aACA,MACA,UACA,KACA,CACA,2DC/FA;AACA,8BACA,aACA,mBACA,iBACA,gBACA,EACA,0BACA,UACA,6BACA,2BACA,YACA,aACA,EACA,iBACA,CACA,aACA,CACA,CACA,qBACA,aACA,CACA,OACA,wBACA,0BAEA,mBACA,iBACA,cACA,YACA,0BACA,iBACA,0BACA,MACA,CACA,aACA,YACA,OACA,cACA,cACA,mBACA,SACA,CACA,8BACA,qCACA,yBACA,oCACA,qBACA,GACA,CACA,yBACA,sCACA,uBACA,GACA,CACA,EACA;AACA,wBACA,UACA,eACA,OACA,6BACA,0BACA,SACA,wBACA,qBACA,eACA,gBACA;AACA,iBACA,GACA,gBACA,CACA,gBACA,yBACA,kBACA,iBACA,4BACA,gCACA,aACA,KACA,8BACA,iBACA,oCACA,EACA,mCACA,2BACA,iBACA,oCACA,kCACA,4CC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,aACA;AACA;AACA;AACA,iCACA,iDACA,MACA,CACA,0CACA,UACA,WACA,YAEA,0CACA,OACA,KAEA,YACA,kBAEA,iBACA,mDACA,iBACA,QAEA,YACA,OACA;0BACA,KACA,QAEA,uBACA,4BACA,qBACA,gBAEA,YACA,iBACA,uBACA,QACA,MACA,OACA,GAEA,sBACA,2BAEA,gCACA,QACA,2BACA,aACA,QACA,gBACA,GACA,CAEA,OACA,KACA,EACA,uCACA,6CACA,iBACA,6CCpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,aACA,qDACA,cACA,6CACA,eAEA,OACA,0BAEA,YACA,8BAEA,GACA,cAEA,IACA,EACA,wCACA,UACA,WACA,kBACA,KACA,UAEA,mEACA,uCACA,kDACA,sBACA,8BACA,iDACA,YACA,UACA,qDACA,KACA,SAEA,KAEA,gBACA,uDACA,yCACA,MACA,EACA,uCACA,6CACA,iBACA,EACA,kBACA,yBACA,WACA,+BACA,kBACA,IACA,OACA,KACA,CACA,yCACA,SACA,sBACA,2DACA,KACA,OACA,KACA,6CCpFA,aACA,iDACA,yCACA,gFCJA,CAUA;;;;;;;;GACA,uCACA,SACA,cACA,kCACA,EACA,YAEA,qBACA,uCACA,KAEA,OACA,mDCvBA,aACA,4BACA,2CACA,0CAEA,0CACA,OACA,KAEA,0BACA,KACA,6CCRA;;GACA,+BACA,6BACA,0CACA,qBACA,eAIA;;GACA,SACA,gCACA;KACA,2CACA;KACA,WACA;KACA,KACA,CAIA;;GACA,gBACA,EAWA;;;;;;;;;GACA,oBACA,0BAEA,YACA,SACA,oBACA,oBACA,0BACA,MACA,cAEA,QACA,CAIA;;GACA,0DACA,SAIA;;GACA,yBACA,SACA,wDACA,+BACA,WACA,uBACA,6DACA,8DACA,8DACA,0DACA,CACA,OACA,OACA,EAQA;;;;;;GACA,YACA,iCACA,kDACA,EAQA;;;;;;GACA,uBACA,yBACA,eACA,sBACA,mBACA,uCACA,MACA,CACA,mBACA,KACA,CASA;;;;;;;GACA,+CACA,uBACA,+BACA,mCACA,GACA,GACA,+BACA,4BACA,MACA,CAKA;;2BAEA,UAOA;;;;;;IACA,yBACA,SACA,uBACA,QACA,UAEA,6CACA,YACA,oBACA,gEACA,IAEA,OACA,KACA,CAIA;;GACA,oBACA,YAOA;;;;;GACA,cACA,MACA,iBACA,uBACA,6BACA,2CACA,gDAEA,qCAUA;;;;;;;qBACA,qCACA,kCAGA,WAQA;;;;;;;IACA,cACA,qCACA,oCAEA,OASA;;;;;;;GACA,yBACA,qBACA,oBACA,MACA,UACA,SACA,UAEA,iBAEA;uCACA,YACA,sBACA,+BACA,wCACA,kBACA,IAEA,OACA,QACA,CAQA;;;;;;GACA,qBACA,2BACA,MACA,CAQA;;;;;;GACA,kBACA,2BACA,QACA,EAQA;;;;;;GACA,oBACA,mDACA,qBACA,mBACA,kBAEA,6BACA,UACA,OACA,IACA,EA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,8BACA,kBACA,YACA,sBACA,IACA;gIACA,qBACA,aACA,kCACA,6CACA,sDACA,yBACA;AACA;AACA;uDACA,8CACA,mCACA,mDACA,UACA,KACA,CAQA;;;;;;GACA,sCACA,0BACA,eACA,EAYA;;;;;;;;;;GACA,uDACA,CACA;oCACA,kBAEA,IACA;eACA,sCACA,MACA,EAWA;;;;;;;;;GACA,0CACA,8BACA,mCACA,qBACA,oBACA,+CACA,eACA,KACA,KACA,EAqBA;;;;;;;;;;;;;;;;;;;GACA,uDACA,CACA;iBACA,QACA,IAEA,qBAEA,EACA;4BACA,uBAEA,KACA;aACA,gBACA,yBACA,yBACA,4BACA,UACA,UAEA,MACA;mBACA,2BACA,4BACA,8BACA,+BACA,0BACA,2BACA,OACA,EAOA;;;;;GACA,qCACA,cACA,mBACA,mBAEA,sDACA,sBACA,qBACA,kBACA,eAEA,UACA,KACA,EAIA;;GACA,iBACA,SAQA;;;;;;GACA,4BACA,UACA,8BACA,eACA,gBACA,mBACA;gBACA;wBACA,SACA,aAEA,QACA,kBACA,eACA,eACA,oDACA,kBACA,EACA;sEACA,KACA;yDACA,0BACA,KAEA,sBAEA,YACA,0BACA,KAEA,oCACA,0BACA,KAEA,uCACA,+CACA,qBACA,uBAEA,6BACA,KACA,GACA,CAIA;;GACA,2BACA,2BACA,oCACA,KACA,CAOA;;;;;GACA,kCACA,iBACA,oBACA,cACA,aACA,yBACA,eACA,MACA,EAsBA;;;;;;;;;;;;;;;;;;;;GACA,qCACA,8CACA,YACA,MACA,EAeA;;;;;;;;;;;;;GACA,4CACA,oBACA,UACA,MACA,EAoBA;;;;;;;;;;;;;;;;;;GACA,uCACA,wCACA,YACA,MACA,EAUA;;;;;;;;GACA,kDACA,aACA,SACA,MAEA,SAEA,gBACA,UACA,8BACA,wCACA,KAEA,UACA,qBACA,mBACA,KAEA,aACA,MACA,EAcA;;;;;;;;;;;;EACA,qCACA,uCACA,6BACA,WACA,MACA,EAiBA;;;;;;;;;;;;;;;GACA,sDACA,sDACA,YACA,MACA,EACA,yCACA,oBACA,yBACA,WACA,aACA,UACA,EAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,qCACA,kBACA,4BAEA,gBACA;6BACA,qBACA,sBACA,KACA,gCACA,oBACA,0BACA,6DACA,iBACA,qBACA,KACA,UACA,6BACA,KACA,MACA,YACA,KAEA,6BACA,yBACA,cACA,MACA,EAGA;;GACA,+CACA,iBACA,cACA,kHACA,gBACA,UACA,MACA,EACA,mDACA,cACA,SACA,MACA,EASA;;;;;;;GACA,4CACA,aACA,eACA,sBACA,KACA,EAMA;;;;GACA,6CACA,mBACA,gLAEA,qBACA,uBACA,oBAEA,kBACA,KACA,EAMA;;;;GACA,yCACA,kBACA,iDACA,2BACA,sBACA,KACA,EAWA;;;;;;;;;GACA,4CACA,uBACA,WACA,MACA,EASA;;;;;;;GACA,kCACA,UACA,8BACA,oCACA,sBACA,uCAEA,MACA;mBAEA,KACA;iCACA,sBAEA,OACA;AACA;GACA,iDAEA,cACA,8BACA,+BACA,mBACA,mBACA,WACA,OAEA,EACA;6CACA,cACA,4BACA,IACA,aACA,gCACA,GACA,mCACA,gBACA,eACA,IACA,8CACA,uBACA,eACA,UACA,CAKA,CAJA;AACA;AACA;AAGA;yBACA,kCACA,eACA,UACA,UACA,SAEA,CACA;SACA,+BACA,mCACA,SACA,UACA,MAEA,CACA;gCACA,uDACA,eACA,+BACA,MAEA,CACA;6CAEA,KACA;iFACA,CACA;6BACA,oGACA,mEACA,gDACA,MAEA,CACA;6BACA,6BACA,gDACA,QAEA,uBACA,uBACA,cAEA,CACA;oBAEA,MACA;AACA;wCACA,YACA,MAEA,EAIA;;GACA,gBACA,QAUA;;;;;;;;GACA,iCACA,uBACA,6CACA,uBACA,oBACA,UACA,KACA,EAUA;;;;;;;;GACA,kCACA,wBACA,6CACA,sBACA,oBACA,UACA,KACA,EASA;;;;;;;GACA,oBACA,0BACA,mBACA,UACA,KACA,EACA,mBACA,kBACA,IAUA;;;;;;;;GACA,mCACA,yBACA,6CACA,sBACA,oBACA,UACA,KACA,EAUA;;;;;;;;GACA,kCACA,wBACA,6CACA,sBACA,oBACA,UACA,KACA,EAUA;;;;;;;;GACA,iCACA,uBACA,6CACA,sBACA,oBACA,UACA,KACA,wHC9iCA;;;;;;GACA,sBACA,oCACA,6CACA,CACA,eACA,oDCXA;;GACA,qBACA,eAOA;;;;;GACA,6CACA,eACA,oBACA,cACA,MACA,EASA;;;;;;;GACA,gCACA,cACA,SACA,MACA,EAQA;;;;;;GACA,oCACA,eACA,SACA,MACA,EAQA;;;;;;GACA,0CACA,kCACA,yBACA,KACA,GACA,EAIA;;GACA,4BACA,IACA,YACA,MAEA,EASA;;;;;;;GACA,2BACA,2BACA,eACA,EAYA;;;;;;;;;;GACA,0BACA,IAqBA;;;;;;;;;;;;;;;;;;;GACA,+BACA,oBACA,sBACA,oBACA,MACA,OACA,MACA,mCACA,uBACA,UACA,MACA,EAYA;;;;;;;;;;;GACA,6BACA,2BACA,kCACA,aACA,MACA,EAeA;;;;;;;;;;;;;;GACA,gCACA,iCACA,WACA,MACA,6DCtKA;AACA;AAeA;;;;;;;;;;;;;GACA,+CACA,CACA;0BACA,iDACA,KAEA,CACA;uBACA,qCACA,QAEA,sCACA,KACA,CACA,eACA,mDC/BA,8FAGA,CAKA;;;;OAEA,UACA,mEAEA;AACA,iCACA,QACA,OACA,QACA,QACA,gBACA,gBACA;cAEA;AACA,wCACA,qCACA;4CAEA;AACA,4BACA,YACA,8DACA,iEAGA,iBACA,+CACA,gBACA,gCAEA,aACA,yBAEA,IAEA,8EAMA;;;;;wBACA,6BACA,OAEA,CAQA;;;;;;;0BACA,kBACA,kBACA,kBACA,yBACA,SACA,OACA,QAEA,CAUA;;;;;;;;;iCACA,wBACA,gBACA,qBACA,CACA;AACA;gBACA,iBACA,GACA,CACA;sCACA,gCACA,qCACA,mBACA,QAEA,CAaA;;;;;;;;;;;;+BACA,YACA,WACA,gBACA,OACA,MACA,2BACA,yBACA,2DACA,CACA;wBACA,sCACA;8CACA,cACA,CACA;AACA;YACA,OACA,UACA,MACA,aACA,OACA,CACA,OACA,QAEA,CAQA;;;;;;;8BACA,iCACA,YACA,mBACA,QACA,oDACA,2BACA,MACA,4BACA,aACA,gBACA,IAEA,CASA;;;;;;;;oCACA,oBACA,kBACA,GACA,oBACA,kBACA,GACA,oBACA,kBACA,GACA,OACA,MAEA,CAWA;;;;;;;;;;qCACA,CACA;AACA;0CACA,GAEA,CAKA;;;;6CACA,OACA,2CACA,qBACA,2EACA,mBACA,eACA,+CACA,OAEA,CAOA;;;;;;0BACA,CACA;WACA,qBACA,OACA,MACA,IACA,cACA,YACA,MACA,EACA,MACA,KACA,EACA,EACA,MACA,EACA,iCAEA,WACA;AACA;AAEA;wBACA,sBACA,OACA,EAEA,qBACA,CACA;6BACA,OACA,aACA,8BACA,IAEA,CACA;AAEA;wEAEA,CACA;AACA;AACA;AACA;AACA;iDAEA,uBACA,OACA,iBAEA,qCAEA,oDACA,OACA,YAEA,UACA,qCAEA,gBACA,CACA,MAEA,iBACA,gCACA,OACA,YAEA,IAEA,WAEA,mBACA,8BAEA,GACA;AACA;yBACA,OACA,YAEA,YACA,QAEA,IACA;oBAEA,GAEA,mBACA,QAEA,CAOA;;;;;;0BACA,IACA,GACA,MACA,eACA,YACA,KACA,EACA,EACA,EACA,EACA,EACA,oBACA,GACA,oEACA,YACA,iCACA,sBACA,WAEA,QACA;iBAEA,OACA;kBAEA,OACA;EACA,eACA,OAEA,YACA;0BACA,oBACA,wBACA,gCACA,eACA,CAEA,mCAEA,OACA;AAEA;AACA;eACA,aACA,WAEA,CACA;iCAEA,CACA;AACA;mCACA,oBACA,sCACA,GACA,aACA,CAEA,CACA;AACA;qCACA,qDACA,OACA,YAEA,cACA,wBAEA,4BACA,oBAEA,qCACA,OACA,YAEA,oBACA,CACA;8CACA,oCACA,YACA,CACA,MACA,WACA,kBACA,SACA,0DAEA,qBACA,YAEA,+CACA,4DACA,mBACA,IACA,eACA,CAEA,GACA,QAEA,EACA,oBACA,IAEA,CAWA;;;;;;;;;;6BACA,wCACA,2BACA,+BACA,eACA,OACA,GAEA,CAWA;;;;;;;;;;2BACA,wCACA,2BACA,sBACA,QACA,OACA,GAEA,CAEA,8EACA,sCAMA;;;;aACA,OANA,CAaA;;;;;;UACA,QACA,kBAEA,mBACA,cACA,eACA,kBAGA,iBACA,UACA,GA7eA,CA8eA,iIChfA;AACA,0BACA,yBACA,QACA,2HCJA;AACA,6EACA,0FAGA,6CACA,CACA;oBACA,oCACA,8BACA,OACA,YACA,kDACA,CACA;sGACA,iBACA,UACA,CACA;oBACA,iBACA,IACA,CACA;AACA;AACA;MACA,YAEA,CAvBA,CADA,uDCHA;AACA,wFACA,4CACA,gBACA,WACA,iBACA,UACA,yCACA,sBACA,IACA,kBACA,0BACA,sBACA,uBACA,0BACA,GACA,yBACA,oBACA,IACA,KACA,aACA,GACA,CACA,qBACA,iBACA,IACA,oBACA,YACA;oUACA,WACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;mWACA,OACA;oiCACA,8BACA,YACA,cACA,+BACA,4BACA,yCACA,OACA,sBACA,mLACA,GACA,gEAEA,4CACA,+CACA,kBACA,6BACA,2DACA,kBACA,4BACA,CACA,iEACA,mBACA,8BACA,kCACA,sCACA,4CACA,6BACA,mBACA,QACA,iCACA,sDACA,iBACA,MACA,CACA,UACA,6DACA,SACA,UACA,uDACA,SACA,MACA,uBACA,uFACA,SAEA,OACA,IACA,kCACA,QACA,kBACA,4CACA,sBACA,wCACA,8DACA,CACA;GACA,iEACA,eACA,SACA,+GACA,EACA,CACA,KACA,gDACA,cACA,iBACA,KACA,OACA,YACA,CA1DA,iDA2DA,2BACA,UACA,mCACA,sBACA,iCACA,kCACA,qCACA,yHACA,6CACA,CACA;GACA,8GACA,QACA,SACA,8IACA,EACA,CACA,KACA,2HACA,YACA,qBACA,OACA,yBACA,KACA,oDACA,iBACA,sCACA,sBACA,gCACA,gBACA,6BACA,gCACA,kHACA,YACA,mHACA,aACA,CACA,kBACA,8BACA,KACA,OACA,YAEA,GACA,4EC7JA;AACA,6EACA,gDAEA,qaACA,2DACA;mBACA,yCACA,oDACA,0BACA,sBACA,oCACA,6BACA,+BACA,WACA,YACA,0BACA,wCACA,QACA;AACA;kBACA,CACA;kCACA,yCACA,OACA,YACA,+BAEA,WACA,mBACA,+BACA,6CACA,SACA,KACA,oCACA,yBACA,OACA,YACA,kDACA,8CACA,kCACA,0BACA,wBACA,wBACA,QACA,mBACA,uGACA,IACA,OACA,YAEA,GACA;wBACA,yCACA,wEACA,oCACA,qBACA,OACA,YACA,kDACA,CACA;uEACA,CACA;kBACA,UACA,KACA,CACA;sCACA,cACA,gDACA,SAEA,GACA,IAtEA,uDCKA;;;;;;;;GA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;GACA;AACA;AAIA;;;GACA,mBAIA;;;GACA,0BAIA;;;GACA,+BACA,kBACA,iBACA,UACA,yCACA,sBACA,IACA,kBACA,0BACA,sBACA,uBACA,0BACA,GACA,yBACA,oBACA,IACA,KACA,aACA,GACA,CACA,qBACA,iBACA,IACA,0BACA,yoHACA,WACA,gFACA,sEACA,0EACA,mEACA,4EACA,kFACA,gGACA,wFACA,8DACA,wCACA,oEACA,yCAEA,MACA,uWACA,kCACA,yBACA,OACA,yBACA,wBACA,yBACA,wBACA,6EAEA,yIACA,oBACA,GACA,0BACA,sCACA,cACA,8BACA,aACA,6BACA,MACA,EACA,uBACA,YACA,+BACA,6CACA,IACA,KACA,sBACA,GACA,IACA,EACA,gBACA,YACA,+BACA,kCACA,yDACA,IACA,KACA,sBACA,GACA,IACA,EACA,KACA,sBACA,MACA,EACA,CACA,OACA,QACA,mBACA,wHACA,cACA,0BACA,YACA,cACA,aACA,4DACA,+BACA,wBACA,kDACA,OACA,eACA,4IACA,6BACA,gLACA,kCACA,kLACA,kCACA,iNACA,mCACA,uKACA,sCACA,gLACA,mBACA,YACA,CACA,kCACA,iCACA,qHACA,qCACA,+DACA,mCACA,kCACA,oBACA,eACA,CACA;wBACA,IACA,KACA,CACA;yBACA,IACA,CACA,aACA,YACA,iBACA,4CACA,qDACA,WACA,CACA,KACA,yBACA,WACA,YACA,0BACA,CACA;0BACA,GACA;4BACA,2BACA,uCACA,gCACA,4BACA,+BACA,GACA;0BACA,yBACA,GACA,CACA,KACA,CACA;8BACA,UACA;2DACA,kEACA,8CACA,gCACA,2DACA,qEACA,UACA;0BACA,6EACA,UACA,CACA,CACA;4KACA,sBACA,gBACA,uCACA,sBACA,WACA,yCACA,sBACA,WACA,KACA,sBACA,MACA,CACA;6FACA,sEACA,cACA,CACA;8DACA,eACA;6HACA,CACA;kFACA,CACA;GACA,4FACA,eACA,SACA,sGACA,EACA,CACA,CACA;uCACA,cACA,KACA,CACA;uCACA,UACA,CACA;sCACA,gCACA,SACA,CACA,KACA,YACA,wCACA,yBACA,OACA,YACA,CACA,iDACA,eACA,sCACA,2BACA,yBACA,KACA,gCACA,2BACA,MACA,sCACA,gBACA,6CACA,KACA,4CACA,UACA,CACA,kCACA,eACA,qBACA,sBACA,0BACA,IACA,2BACA,0BACA,KACA,2BACA,0BACA,YACA,MACA,mCACA,OACA,GACA,KACA,qBACA,uBACA,oBACA,GACA,CACA,oBACA,IACA,CACA,uCACA,iCACA,2GACA,EACA;8DACA,eACA;gCACA,6CACA,SACA;mIACA,CACA;GACA,sJACA,MACA,SACA,qIACA,EACA,CACA,CACA;uCACA,6DACA,2BACA,uBACA,KACA,0CACA,kCACA,iCACA,gBACA,MACA,gBACA,+DACA,gBACA,KACA,CACA,gCACA,cACA,6EACA,qBACA,GACA,0BACA,6BACA;AACA,gBACA,GACA,iCACA,gBACA,+BACA,OACA,oCACA,gBACA,+BACA,UACA,2BACA;AACA,CACA,oEACA,iCACA,YACA,yBACA,6CACA;oDACA;AACA,kBACA,yCACA,wBACA,OACA;yBACA,8BACA,0BACA,4CACA,4BACA,MACA,KACA,wFACA,CACA;yBACA,8BACA,0BACA,4CACA,4BACA,MACA,KACA,mBACA,kBACA,mCACA,uBACA,MACA,KACA,mBACA,MACA,CACA,KACA,kCACA,wCACA,MACA,KACA,0FACA,0BACA,KACA,oBACA,sBACA,KA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","file":"json-schema-form-core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 72dc4632fd39a22e4991","export { parse } from 'objectpath';\r\nexport { stringify } from 'objectpath';\r\nexport { normalize } from 'objectpath';\r\n\r\n/**\r\n * I am a name formatter function for processing keys into names for classes or Id.\r\n *\r\n * @param  {Array<string>} key         I am the key array of a processed schema key\r\n * @param  {string}        separator   I am the separator between the key items and optional form name\r\n * @param  {string}        formName    I am an optional form name\r\n * @param  {boolean}       omitNumbers I determine if numeric values should be included in the output or withheld\r\n *\r\n * @return {string}                    I am the formatted key\r\n */\r\nexport function name (key: Array<string>, separator?: string, formName = '', omitNumbers = false) {\r\n  if (key) {\r\n    let fieldKey = key.slice();\r\n    let fieldSeparator = separator || '-';\r\n\r\n    if (omitNumbers) {\r\n      fieldKey = fieldKey.filter(function(currentKey: any) {\r\n        return typeof currentKey !== 'number';\r\n      });\r\n    };\r\n\r\n    return ((formName.length !== 0)\r\n      ? formName + fieldSeparator\r\n      : ''\r\n    ) + fieldKey.join(fieldSeparator);\r\n  };\r\n\r\n  return '';\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/sf-path.js","// Takes a titleMap in either object or list format and returns one\r\n// in the list format.\r\nexport default function(titleMap: Array<any>, originalEnum?: any) {\r\n  if (!Array.isArray(titleMap)) {\r\n    const canonical = [];\r\n    if (originalEnum) {\r\n      originalEnum.forEach((value) => {\r\n        canonical.push({ name: titleMap[value], value });\r\n      });\r\n    }\r\n    else {\r\n      Object.keys(titleMap).forEach((value) => {\r\n        canonical.push({ name: titleMap[value], value });\r\n      });\r\n    }\r\n    return canonical;\r\n  }\r\n  return titleMap;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/canonical-title-map.js","module.exports = require('./lib/ObjectPath.js').ObjectPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/index.js\n// module id = 2\n// module chunks = 0","import { stringify } from './sf-path';\r\nimport canonicalTitleMap from './canonical-title-map';\r\n\r\n/* Utils */\r\nconst stripNullType = (type) => {\r\n  if (Array.isArray(type) && type.length === 2) {\r\n    if (type[0] === 'null') {\r\n      return type[1];\r\n    };\r\n    if (type[1] === 'null') {\r\n      return type[0];\r\n    };\r\n  };\r\n  return type;\r\n};\r\n\r\n// Creates an default titleMap list from an enum, i.e. a list of strings.\r\nconst enumToTitleMap = (enm) => {\r\n  const titleMap = []; // canonical titleMap format is a list.\r\n  enm.forEach((name) => {\r\n    titleMap.push({ name, value: name });\r\n  });\r\n  return titleMap;\r\n};\r\n\r\n/**\r\n * Creates a default form definition from a schema.\r\n */\r\nexport function defaultFormDefinition(schemaTypes, name, schema, options) {\r\n  const rules = schemaTypes[stripNullType(schema.type)];\r\n  if (rules) {\r\n    let def;\r\n    // We give each rule a possibility to recurse it's children.\r\n    const innerDefaultFormDefinition = (childName, childSchema , childOptions) =>\r\n                          defaultFormDefinition(schemaTypes, childName, childSchema, childOptions);\r\n    for (let i = 0; i < rules.length; i++) {\r\n      def = rules[i](name, schema, options, innerDefaultFormDefinition);\r\n\r\n      // first handler in list that actually returns something is our handler!\r\n      if (def) {\r\n\r\n        // Do we have form defaults in the schema under the x-schema-form-attribute?\r\n        if (def.schema['x-schema-form']) {\r\n          Object.assign(def, def.schema['x-schema-form']);\r\n        }\r\n\r\n        return def;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a form object with all common properties\r\n */\r\nexport function stdFormObj(name, schema, options) {\r\n  options = options || {};\r\n\r\n  // The Object.assign used to be a angular.copy. Should work though.\r\n  const f = options.global && options.global.formDefaults ?\r\n          Object.assign({}, options.global.formDefaults) : {};\r\n  if (options.global && options.global.supressPropertyTitles === true) {\r\n    f.title = schema.title;\r\n  }\r\n  else {\r\n    f.title = schema.title || name;\r\n  }\r\n\r\n  if (schema.description) { f.description = schema.description; }\r\n  if (options.required === true || schema.required === true) { f.required = true; }\r\n  if (schema.maxLength) { f.maxlength = schema.maxLength; }\r\n  if (schema.minLength) { f.minlength = schema.minLength; }\r\n  if (schema.readOnly || schema.readonly) { f.readonly  = true; }\r\n  if (schema.minimum) { f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0); }\r\n  if (schema.maximum) { f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0); }\r\n\r\n  // Non standard attributes (DONT USE DEPRECATED)\r\n  // If you must set stuff like this in the schema use the x-schema-form attribute\r\n  if (schema.validationMessage) { f.validationMessage = schema.validationMessage; }\r\n  if (schema.enumNames) { f.titleMap = canonicalTitleMap(schema.enumNames, schema['enum']); }\r\n  f.schema = schema;\r\n\r\n  // Ng model options doesn't play nice with undefined, might be defined\r\n  // globally though\r\n  f.ngModelOptions = f.ngModelOptions || {};\r\n\r\n  return f;\r\n};\r\n\r\n/*** Schema types to form type mappings, with defaults ***/\r\nexport function text(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'string' && !schema['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'text';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\n// default in json form for number and integer is a text field\r\n// input type=\"number\" would be more suitable don't ya think?\r\nexport function number(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'number') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'number';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function integer(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'integer') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'number';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function checkbox(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'boolean') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'checkbox';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function select(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'string' && schema['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'select';\r\n    if (!f.titleMap) {\r\n      f.titleMap = enumToTitleMap(schema['enum']);\r\n    }\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function checkboxes(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'array' && schema.items && schema.items['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'checkboxes';\r\n    if (!f.titleMap) {\r\n      f.titleMap = enumToTitleMap(schema.items['enum']);\r\n    }\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function fieldset(name, schema, options, defaultFormDef) {\r\n  if (stripNullType(schema.type) === 'object') {\r\n    const f   = stdFormObj(name, schema, options);\r\n    f.type  = 'fieldset';\r\n    f.key   = options.path;\r\n    f.items = [];\r\n    options.lookup[stringify(options.path)] = f;\r\n\r\n    // recurse down into properties\r\n    if (schema.properties) {\r\n      Object.keys(schema.properties).forEach((key) => {\r\n        const value = schema.properties[key];\r\n        const path = options.path.slice();\r\n        path.push(key);\r\n        if (options.ignore[stringify(path)] !== true) {\r\n          const required = schema.required && schema.required.indexOf(key) !== -1;\r\n\r\n          const def = defaultFormDef(key, value, {\r\n            path,\r\n            required: required || false,\r\n            lookup: options.lookup,\r\n            ignore: options.ignore,\r\n            global: options.global\r\n          });\r\n          if (def) {\r\n            f.items.push(def);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function array(name, schema, options, defaultFormDef) {\r\n  if (stripNullType(schema.type) === 'array') {\r\n    const f   = stdFormObj(name, schema, options);\r\n    f.type  = 'array';\r\n    f.key   = options.path;\r\n    options.lookup[stringify(options.path)] = f;\r\n\r\n    const required = schema.required &&\r\n                   schema.required.indexOf(options.path[options.path.length - 1]) !== -1;\r\n\r\n    // The default is to always just create one child. This works since if the\r\n    // schemas items declaration is of type: \"object\" then we get a fieldset.\r\n    // We also follow json form notatation, adding empty brackets \"[]\" to\r\n    // signify arrays.\r\n\r\n    const arrPath = options.path.slice();\r\n    arrPath.push('');\r\n\r\n    f.items = [\r\n      defaultFormDef(name, schema.items, {\r\n        path: arrPath,\r\n        required: required || false,\r\n        lookup: options.lookup,\r\n        ignore: options.ignore,\r\n        global: options.global\r\n      })\r\n    ];\r\n\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function createDefaults() {\r\n  // First sorted by schema type then a list.\r\n  // Order has importance. First handler returning an form snippet will be used.\r\n  return {\r\n    string:  [ select, text ],\r\n    object:  [ fieldset ],\r\n    number:  [ number ],\r\n    integer: [ integer ],\r\n    boolean: [ checkbox ],\r\n    array:   [ checkboxes, array ]\r\n  };\r\n};\r\n\r\n/**\r\n * Create form defaults from schema\r\n */\r\nexport function defaultForm(schema: any, defaultSchemaTypes: any, ignore?: any, globalOptions?: any) {\r\n  const form   = [];\r\n  const lookup = {}; // Map path => form obj for fast lookup in merging\r\n  ignore = ignore || {};\r\n  globalOptions = globalOptions || {};\r\n  defaultSchemaTypes = defaultSchemaTypes || createDefaults();\r\n\r\n  if (schema.properties) {\r\n    Object.keys(schema.properties).forEach((key) => {\r\n      if (ignore[key] !== true) {\r\n        const required = schema.required && schema.required.indexOf(key) !== -1;\r\n        const def = defaultFormDefinition(defaultSchemaTypes, key, schema.properties[key], {\r\n          path: [ key ],         // Path to this property in bracket notation.\r\n          lookup: lookup,    // Extra map to register with. Optimization for merger.\r\n          ignore: ignore,    // The ignore list of paths (sans root level name)\r\n          required: required, // Is it required? (v4 json schema style)\r\n          global: globalOptions // Global options, including form defaults\r\n        });\r\n        if (def) {\r\n          form.push(def);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  else {\r\n    throw new Error('Not implemented. Only type \"object\" allowed at root level of schema.');\r\n  }\r\n  return { form: form, lookup: lookup };\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/schema-defaults.js","import * as schemaDefaultsImp from './lib/schema-defaults';\r\nimport * as sfPathImp from './lib/sf-path';\r\nimport canonicalTitleMapImp from './lib/canonical-title-map';\r\n\r\nexport { merge } from './lib/merge';\r\nexport { select }  from './lib/select';\r\nexport { jsonref }  from './lib/resolve';\r\nexport { traverseSchema, traverseForm } from './lib/traverse';\r\nexport { validate } from './lib/validate';\r\n\r\nexport const sfPath = sfPathImp;\r\nexport const schemaDefaults = schemaDefaultsImp;\r\nexport const canonicalTitleMap = canonicalTitleMapImp;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/module.js","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\n\n\n// WEBPACK FOOTER //\n// node_modules/browser-pack/_prelude.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and\n * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.\n *\n * @module JsonRefs\n */\n\nvar path = require('path');\nvar PathLoader = require('path-loader');\nvar qs = require('querystring');\nvar slash = require('slash');\nvar URI = require('uri-js');\n\nvar badPtrTokenRegex = /~(?:[^01]|$)/g;\nvar remoteCache = {};\nvar remoteTypes = ['relative', 'remote'];\nvar remoteUriTypes = ['absolute', 'uri'];\nvar uriDetailsCache = {};\n\n// Load promises polyfill if necessary\n/* istanbul ignore if */\nif (typeof Promise === 'undefined') {\n  require('native-promise-only');\n}\n\n/* Internal Functions */\n\n// This is a very simplistic clone function that does not take into account non-JSON types.  For these types the\n// original value is used as the clone.  So while it's not a complete deep clone, for the needs of this project\n// this should be sufficient.\nfunction clone (obj) {\n  var cloned;\n\n  if (isType(obj, 'Array')) {\n    cloned = [];\n\n    obj.forEach(function (value, index) {\n      cloned[index] = clone(value);\n    });\n  } else if (isType(obj, 'Object')) {\n    cloned = {};\n\n    Object.keys(obj).forEach(function (key) {\n      cloned[key] = clone(obj[key]);\n    });\n  } else {\n    cloned = obj;\n  }\n\n  return cloned;\n}\n\nfunction combineQueryParams (qs1, qs2) {\n  var combined = {};\n\n  function mergeQueryParams (obj) {\n    Object.keys(obj).forEach(function (key) {\n      combined[key] = obj[key];\n    });\n  }\n\n  mergeQueryParams(qs.parse(qs1 || ''));\n  mergeQueryParams(qs.parse(qs2 || ''));\n\n  return Object.keys(combined).length === 0 ? undefined : qs.stringify(combined);\n}\n\nfunction combineURIs (u1, u2) {\n  // Convert Windows paths\n  if (isType(u1, 'String')) {\n    u1 = slash(u1);\n  }\n\n  if (isType(u2, 'String')) {\n    u2 = slash(u2);\n  }\n\n  var u2Details = parseURI(isType(u2, 'Undefined') ? '' : u2);\n  var u1Details;\n  var combinedDetails;\n\n  if (remoteUriTypes.indexOf(u2Details.reference) > -1) {\n    combinedDetails = u2Details;\n  } else {\n    u1Details = isType(u1, 'Undefined') ? undefined : parseURI(u1);\n\n    if (!isType(u1Details, 'Undefined')) {\n      combinedDetails = u1Details;\n\n      // Join the paths\n      combinedDetails.path = slash(path.join(u1Details.path, u2Details.path));\n\n      // Join query parameters\n      combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);\n    } else {\n      combinedDetails = u2Details;\n    }\n  }\n\n  // Remove the fragment\n  combinedDetails.fragment = undefined;\n\n  // For relative URIs, add back the '..' since it was removed above\n  return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 &&\n          combinedDetails.path.indexOf('../') === 0 ? '../' : '') + URI.serialize(combinedDetails);\n}\n\nfunction findAncestors (obj, path) {\n  var ancestors = [];\n  var node;\n\n  if (path.length > 0) {\n    node = obj;\n\n    path.slice(0, path.length - 1).forEach(function (seg) {\n      if (seg in node) {\n        node = node[seg];\n\n        ancestors.push(node);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction processSubDocument (mode, doc, subDocPath, refDetails, options, parents, parentPtrs, allRefs, indirect) {\n  var refValue;\n  var rOptions;\n\n  if (subDocPath.length > 0) {\n    try {\n      refValue = findValue(doc, subDocPath);\n    } catch (err) {\n      // We only mark missing remote references as missing because local references can have deferred values\n      if (mode === 'remote') {\n        refDetails.error = err.message;\n        refDetails.missing = true;\n      }\n    }\n  } else {\n    refValue = doc;\n  }\n\n  if (!isType(refValue, 'Undefined')) {\n    refDetails.value = refValue;\n  }\n\n  if (isType(refValue, 'Array') || isType(refValue, 'Object')) {\n    rOptions = clone(options);\n\n    if (mode === 'local') {\n      delete rOptions.subDocPath;\n\n      // Traverse the dereferenced value\n      doc = refValue;\n    } else {\n      rOptions.relativeBase = path.dirname(parents[parents.length - 1]);\n\n      if (subDocPath.length === 0) {\n        delete rOptions.subDocPath;\n      } else {\n        rOptions.subDocPath = subDocPath;\n      }\n    }\n\n    return findRefsRecursive(doc, rOptions, parents, parentPtrs, allRefs, indirect);\n  }\n}\n\n// Should this be its own exported API?\nfunction findRefsRecursive (obj, options, parents, parentPtrs, allRefs, indirect) {\n  var allTasks = Promise.resolve();\n  var parentPath = parentPtrs.length ? pathFromPtr(parentPtrs[parentPtrs.length - 1]) : [];\n  var refs = findRefs(obj, options);\n  var subDocPath = options.subDocPath || [];\n  var subDocPtr = pathToPtr(subDocPath);\n  var ancestorPtrs = ['#'];\n\n  parents.forEach(function (parent, index) {\n    if (parent.charAt(0) !== '#') {\n      ancestorPtrs.push(parentPtrs[index]);\n    }\n  });\n\n  // Reverse the order so we search them in the proper order\n  ancestorPtrs.reverse();\n\n  if ((parents[parents.length - 1] || '').charAt(0) !== '#') {\n    allRefs.documents[pathToPtr(parentPath)] = obj;\n  }\n\n  Object.keys(refs).forEach(function (refPtr) {\n    var refDetails = refs[refPtr];\n    var location;\n    var parentIndex;\n    var refFullPath;\n    var refFullPtr;\n\n    // If there are no parents, treat the reference pointer as-is.  Otherwise, the reference is a reference within a\n    // remote document and its sub document path prefix must be removed.\n    if (parents.length === 0) {\n      refFullPath = parentPath.concat(pathFromPtr(refPtr));\n    } else {\n      refFullPath = parentPath.concat(pathFromPtr(refPtr).slice(parents.length === 0 ? 0 : subDocPath.length));\n    }\n\n    refFullPtr = pathToPtr(refFullPath);\n\n    // It is possible to process the same reference more than once in the event of hierarchical references so we avoid\n    // processing a reference if we've already done so.\n    if (!isType(allRefs[refFullPtr], 'Undefined')) {\n      return;\n    }\n\n    // Record the reference metadata\n    allRefs.refs[refFullPtr] = refs[refPtr];\n\n    // Do not process invalid references\n    if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n      if (remoteTypes.indexOf(refDetails.type) > -1) {\n        location = combineURIs(options.relativeBase, refDetails.uri);\n        parentIndex = parents.indexOf(location);\n      } else {\n        location = refDetails.uri;\n        parentIndex = parentPtrs.indexOf(location);\n      }\n\n      // Record ancestor paths\n      refDetails.ancestorPtrs = ancestorPtrs;\n\n      // Record if the reference is indirect based on its parent\n      refDetails.indirect = indirect;\n\n      // Only process non-circular references further\n      if (parentIndex === -1) {\n        if (remoteTypes.indexOf(refDetails.type) > -1) {\n          allTasks = allTasks\n            .then(function () {\n              return getRemoteDocument(location, options)\n                .then(function (doc) {\n                  return processSubDocument('remote',\n                                            doc,\n                                            isType(refDetails.uriDetails.fragment, 'Undefined') ?\n                                              [] :\n                                              pathFromPtr(decodeURI(refDetails.uriDetails.fragment)),\n                                            refDetails,\n                                            options,\n                                            parents.concat(location),\n                                            parentPtrs.concat(refFullPtr),\n                                            allRefs,\n                                            indirect);\n                })\n                .catch(function (err) {\n                  refDetails.error = err.message;\n                  refDetails.missing = true;\n                });\n            });\n        } else {\n          if (refFullPtr.indexOf(location + '/') !== 0 && refFullPtr !== location &&\n              subDocPtr.indexOf(location + '/') !== 0 && subDocPtr !== location) {\n            if (location.indexOf(subDocPtr + '/') !== 0) {\n              allTasks = allTasks\n                .then(function () {\n                  return processSubDocument('local',\n                                            obj,\n                                            pathFromPtr(location),\n                                            refDetails,\n                                            options,\n                                            parents.concat(location),\n                                            parentPtrs.concat(refFullPtr),\n                                            allRefs,\n                                            indirect || (location.indexOf(subDocPtr + '/') === -1 && location !== subDocPtr));\n                });\n            }\n          } else {\n            refDetails.circular = true;\n          }\n        }\n      } else {\n        // Mark seen ancestors as circular\n        parentPtrs.slice(parentIndex).forEach(function (parentPtr) {\n          allRefs.refs[parentPtr].circular = true;\n        });\n\n        refDetails.circular = true;\n      }\n    }\n  });\n\n  allTasks = allTasks\n    .then(function () {\n      // Identify indirect, local circular references (Issue 82)\n      var circulars = [];\n      var processedRefPtrs = [];\n      var processedRefs = [];\n\n      function walkRefs (parentPtrs, parentRefs, refPtr, ref) {\n        Object.keys(allRefs.refs).forEach(function (dRefPtr) {\n          var dRefDetails = allRefs.refs[dRefPtr];\n\n          // Do not process already processed references or references that are not a nested references\n          if (processedRefs.indexOf(ref) === -1 && processedRefPtrs.indexOf(refPtr) === -1 &&\n              circulars.indexOf(ref) === -1 && dRefPtr !== refPtr && dRefPtr.indexOf(ref + '/') === 0) {\n            if (parentRefs.indexOf(ref) > -1) {\n              parentRefs.forEach(function (parentRef) {\n                if (circulars.indexOf(ref) === -1) {\n                  circulars.push(parentRef);\n                }\n              });\n            } else {\n              walkRefs(parentPtrs.concat(refPtr), parentRefs.concat(ref), dRefPtr, dRefDetails.uri);\n            }\n\n            processedRefPtrs.push(refPtr);\n            processedRefs.push(ref);\n          }\n        });\n      }\n\n      Object.keys(allRefs.refs).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        // Only process local, non-circular references\n        if (refDetails.type === 'local' && !refDetails.circular && circulars.indexOf(refDetails.uri) === -1) {\n          walkRefs([], [], refPtr, refDetails.uri);\n        }\n      });\n\n      Object.keys(allRefs.refs).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        if (circulars.indexOf(refDetails.uri) > -1) {\n          refDetails.circular = true;\n        }\n      });\n    })\n    .then(function () {\n      return allRefs;\n    });\n\n  return allTasks;\n}\n\nfunction findValue (obj, path) {\n  var value = obj;\n\n  path.forEach(function (seg) {\n    seg = decodeURI(seg);\n\n    if (seg in value) {\n      value = value[seg];\n    } else {\n      throw Error('JSON Pointer points to missing location: ' + pathToPtr(path));\n    }\n  });\n\n  return value;\n}\n\nfunction getExtraRefKeys (ref) {\n  return Object.keys(ref).filter(function (key) {\n    return key !== '$ref';\n  });\n}\n\nfunction getRefType (refDetails) {\n  var type;\n\n  // Convert the URI reference to one of our types\n  switch (refDetails.uriDetails.reference) {\n  case 'absolute':\n  case 'uri':\n    type = 'remote';\n    break;\n  case 'same-document':\n    type = 'local';\n    break;\n  default:\n    type = refDetails.uriDetails.reference;\n  }\n\n  return type;\n}\n\nfunction getRemoteDocument (url, options) {\n  var cacheEntry = remoteCache[url];\n  var allTasks = Promise.resolve();\n  var loaderOptions = clone(options.loaderOptions || {});\n\n  if (isType(cacheEntry, 'Undefined')) {\n    // If there is no content processor, default to processing the raw response as JSON\n    if (isType(loaderOptions.processContent, 'Undefined')) {\n      loaderOptions.processContent = function (res, callback) {\n        callback(undefined, JSON.parse(res.text));\n      };\n    }\n\n    // Attempt to load the resource using path-loader\n    allTasks = PathLoader.load(decodeURI(url), loaderOptions);\n\n    // Update the cache\n    allTasks = allTasks\n      .then(function (res) {\n        remoteCache[url] = {\n          value: res\n        };\n\n        return res;\n      })\n      .catch(function (err) {\n        remoteCache[url] = {\n          error: err\n        };\n\n        throw err;\n      });\n  } else {\n    // Return the cached version\n    allTasks = allTasks.then(function () {\n      return cacheEntry.value;\n    });\n  }\n\n  // Return a cloned version to avoid updating the cache\n  allTasks = allTasks.then(function (res) {\n    return clone(res);\n  });\n\n  return allTasks;\n}\n\nfunction isRefLike (obj, throwWithDetails) {\n  var refLike = true;\n\n  try {\n    if (!isType(obj, 'Object')) {\n      throw new Error('obj is not an Object');\n    } else if (!isType(obj.$ref, 'String')) {\n      throw new Error('obj.$ref is not a String');\n    }\n  } catch (err) {\n    if (throwWithDetails) {\n      throw err;\n    }\n\n    refLike = false;\n  }\n\n  return refLike;\n}\n\nfunction isType (obj, type) {\n  // A PhantomJS bug (https://github.com/ariya/phantomjs/issues/11722) prohibits us from using the same approach for\n  // undefined checking that we use for other types.\n  if (type === 'Undefined') {\n    return typeof obj === 'undefined';\n  } else {\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n  }\n}\n\nfunction makeRefFilter (options) {\n  var refFilter;\n  var validTypes;\n\n  if (isType(options.filter, 'Array') || isType(options.filter, 'String')) {\n    validTypes = isType(options.filter, 'String') ? [options.filter] : options.filter;\n    refFilter = function (refDetails) {\n      // Check the exact type or for invalid URIs, check its original type\n      return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;\n    };\n  } else if (isType(options.filter, 'Function')) {\n    refFilter = options.filter;\n  } else if (isType(options.filter, 'Undefined')) {\n    refFilter = function () {\n      return true;\n    };\n  }\n\n  return function (refDetails, path) {\n    return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);\n  };\n}\n\nfunction makeSubDocPath (options) {\n  var subDocPath;\n\n  if (isType(options.subDocPath, 'Array')) {\n    subDocPath = options.subDocPath;\n  } else if (isType(options.subDocPath, 'String')) {\n    subDocPath = pathFromPtr(options.subDocPath);\n  } else if (isType(options.subDocPath, 'Undefined')) {\n    subDocPath = [];\n  }\n\n  return subDocPath;\n}\n\nfunction parseURI (uri) {\n  // We decode first to avoid doubly encoding\n  return URI.parse(encodeURI(decodeURI(uri)));\n}\n\nfunction setValue (obj, refPath, value) {\n  findValue(obj, refPath.slice(0, refPath.length - 1))[decodeURI(refPath[refPath.length - 1])] = value;\n}\n\nfunction walk (ancestors, node, path, fn) {\n  var processChildren = true;\n\n  function walkItem (item, segment) {\n    path.push(segment);\n    walk(ancestors, item, path, fn);\n    path.pop();\n  }\n\n  // Call the iteratee\n  if (isType(fn, 'Function')) {\n    processChildren = fn(ancestors, node, path);\n  }\n\n  // We do not process circular objects again\n  if (ancestors.indexOf(node) === -1) {\n    ancestors.push(node);\n\n    if (processChildren !== false) {\n      if (isType(node, 'Array')) {\n        node.forEach(function (member, index) {\n          walkItem(member, index.toString());\n        });\n      } else if (isType(node, 'Object')) {\n        Object.keys(node).forEach(function (key) {\n          walkItem(node[key], key);\n        });\n      }\n    }\n  }\n\n  ancestors.pop();\n}\n\nfunction validateOptions (options, obj) {\n  if (isType(options, 'Undefined')) {\n    // Default to an empty options object\n    options = {};\n  } else {\n    // Clone the options so we do not alter the ones passed in\n    options = clone(options);\n  }\n\n  if (!isType(options, 'Object')) {\n    throw new TypeError('options must be an Object');\n  } else if (!isType(options.filter, 'Undefined') &&\n             !isType(options.filter, 'Array') &&\n             !isType(options.filter, 'Function') &&\n             !isType(options.filter, 'String')) {\n    throw new TypeError('options.filter must be an Array, a Function of a String');\n  } else if (!isType(options.includeInvalid, 'Undefined') &&\n             !isType(options.includeInvalid, 'Boolean')) {\n    throw new TypeError('options.includeInvalid must be a Boolean');\n  } else if (!isType(options.refPreProcessor, 'Undefined') &&\n             !isType(options.refPreProcessor, 'Function')) {\n    throw new TypeError('options.refPreProcessor must be a Function');\n  } else if (!isType(options.refPostProcessor, 'Undefined') &&\n             !isType(options.refPostProcessor, 'Function')) {\n    throw new TypeError('options.refPostProcessor must be a Function');\n  } else if (!isType(options.subDocPath, 'Undefined') &&\n             !isType(options.subDocPath, 'Array') &&\n             !isPtr(options.subDocPath)) {\n    // If a pointer is provided, throw an error if it's not the proper type\n    throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');\n  }\n\n  options.filter = makeRefFilter(options);\n\n  // Set the subDocPath to avoid everyone else having to compute it\n  options.subDocPath = makeSubDocPath(options);\n\n  if (!isType(obj, 'Undefined')) {\n    try {\n      findValue(obj, options.subDocPath);\n    } catch (err) {\n      err.message = err.message.replace('JSON Pointer', 'options.subDocPath');\n\n      throw err;\n    }\n  }\n\n  return options;\n}\n\n/* Module Members */\n\n/*\n * Each of the functions below are defined as function statements and *then* exported in two steps instead of one due\n * to a bug in jsdoc (https://github.com/jsdoc2md/jsdoc-parse/issues/18) that causes our documentation to be\n * generated improperly.  The impact to the user is significant enough for us to warrant working around it until this\n * is fixed.\n */\n\n/**\n * The options used for various JsonRefs APIs.\n *\n * @typedef {object} JsonRefsOptions\n *\n * @param {string|string[]|function} [filter=function () {return true;}] - The filter to use when gathering JSON\n * References *(If this value is a single string or an array of strings, the value(s) are expected to be the `type(s)`\n * you are interested in collecting as described in {@link module:JsonRefs.getRefDetails}.  If it is a function, it is\n * expected that the function behaves like {@link module:JsonRefs~RefDetailsFilter}.)*\n * @param {boolean} [includeInvalid=false] - Whether or not to include invalid JSON Reference details *(This will make\n * it so that objects that are like JSON Reference objects, as in they are an `Object` and the have a `$ref` property,\n * but fail validation will be included.  This is very useful for when you want to know if you have invalid JSON\n * Reference definitions.  This will not mean that APIs will process invalid JSON References but the reasons as to why\n * the JSON References are invalid will be included in the returned metadata.)*\n * @param {object} [loaderOptions] - The options to pass to\n * {@link https://github.com/whitlockjc/path-loader/blob/master/docs/API.md#module_PathLoader.load|PathLoader~load}\n * @param {module:JsonRefs~RefPreProcessor} [refPreProcessor] - The callback used to pre-process a JSON Reference like\n * object *(This is called prior to validating the JSON Reference like object and getting its details)*\n * @param {module:JsonRefs~RefPostProcessor} [refPostProcessor] - The callback used to post-process the JSON Reference\n * metadata *(This is called prior filtering the references)*\n * @param {string} [options.relativeBase] - The base location to use when resolving relative references *(Only useful\n * for APIs that do remote reference resolution.  If this value is not defined,\n * {@link https://github.com/whitlockjc/path-loader|path-loader} will use `window.location.href` for the browser and\n * `process.cwd()` for Node.js.)*\n * @param {string|string[]} [options.subDocPath=[]] - The JSON Pointer or array of path segments to the sub document\n * location to search from\n */\n\n/**\n * Simple function used to filter out JSON References.\n *\n * @typedef {function} RefDetailsFilter\n *\n * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n * @param {string[]} path - The path to the JSON Reference\n *\n * @returns {boolean} whether the JSON Reference should be filtered *(out)* or not\n */\n\n/**\n * Simple function used to pre-process a JSON Reference like object.\n *\n * @typedef {function} RefPreProcessor\n *\n * @param {object} obj - The JSON Reference like object\n * @param {string[]} path - The path to the JSON Reference like object\n *\n * @returns {object} the processed JSON Reference like object\n */\n\n/**\n * Simple function used to post-process a JSON Reference details.\n *\n * @typedef {function} RefPostProcessor\n *\n * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n * @param {string[]} path - The path to the JSON Reference\n *\n * @returns {object} the processed JSON Reference details object\n */\n\n/**\n * Detailed information about resolved JSON References.\n *\n * @typedef {module:JsonRefs~UnresolvedRefDetails} ResolvedRefDetails\n *\n * @property {boolean} [circular] - Whether or not the JSON Reference is circular *(Will not be set if the JSON\n * Reference is not circular)*\n * @property {boolean} [missing] - Whether or not the referenced value was missing or not *(Will not be set if the\n * referenced value is not missing)*\n * @property {*} [value] - The referenced value *(Will not be set if the referenced value is missing)*\n */\n\n/**\n * The results of resolving the JSON References of an array/object.\n *\n * @typedef {object} ResolvedRefsResults\n *\n * @property {module:JsonRefs~ResolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n * @property {object} resolved - The array/object with its JSON References fully resolved\n */\n\n/**\n * An object containing the retrieved document and detailed information about its JSON References.\n *\n * @typedef {module:JsonRefs~ResolvedRefsResults} RetrievedRefsResults\n *\n * @property {object} value - The retrieved document\n */\n\n/**\n * An object containing the retrieved document, the document with its references resolved and  detailed information\n * about its JSON References.\n *\n * @typedef {object} RetrievedResolvedRefsResults\n *\n * @property {module:JsonRefs~UnresolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~UnresolvedRefDetails}\n * @property {ResolvedRefsResults} - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n * @property {object} value - The retrieved document\n */\n\n/**\n * Detailed information about unresolved JSON References.\n *\n * @typedef {object} UnresolvedRefDetails\n *\n * @property {object} def - The JSON Reference definition\n * @property {string} [error] - The error information for invalid JSON Reference definition *(Only present when the\n * JSON Reference definition is invalid or there was a problem retrieving a remote reference during resolution)*\n * @property {string} uri - The URI portion of the JSON Reference\n * @property {object} uriDetails - Detailed information about the URI as provided by\n * {@link https://github.com/garycourt/uri-js|URI.parse}.\n * @property {string} type - The JSON Reference type *(This value can be one of the following: `invalid`, `local`,\n * `relative` or `remote`.)*\n * @property {string} [warning] - The warning information *(Only present when the JSON Reference definition produces a\n * warning)*\n */\n\n/**\n * Clears the internal cache of remote documents, reference details, etc.\n *\n * @alias module:JsonRefs.clearCache\n */\nfunction clearCache () {\n  remoteCache = {};\n}\n\n/**\n * Takes an array of path segments and decodes the JSON Pointer tokens in them.\n *\n * @param {string[]} path - The array of path segments\n *\n * @returns {string} the array of path segments with their JSON Pointer tokens decoded\n *\n * @throws {Error} if the path is not an `Array`\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @alias module:JsonRefs.decodePath\n */\nfunction decodePath (path) {\n  if (!isType(path, 'Array')) {\n    throw new TypeError('path must be an array');\n  }\n\n  return path.map(function (seg) {\n    if (!isType(seg, 'String')) {\n      seg = JSON.stringify(seg);\n    }\n\n    return decodeURI(seg.replace(/~1/g, '/').replace(/~0/g, '~'));\n  });\n}\n\n/**\n * Takes an array of path segments and encodes the special JSON Pointer characters in them.\n *\n * @param {string[]} path - The array of path segments\n *\n * @returns {string} the array of path segments with their JSON Pointer tokens encoded\n *\n * @throws {Error} if the path is not an `Array`\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @alias module:JsonRefs.encodePath\n */\nfunction encodePath (path) {\n  if (!isType(path, 'Array')) {\n    throw new TypeError('path must be an array');\n  }\n\n  return path.map(function (seg) {\n    if (!isType(seg, 'String')) {\n      seg = JSON.stringify(seg);\n    }\n\n    return seg.replace(/~/g, '~0').replace(/\\//g, '~1');\n  });\n}\n\n/**\n * Finds JSON References defined within the provided array/object.\n *\n * @param {array|object} obj - The structure to find JSON References within\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {object} an object whose keys are JSON Pointers *(fragment version)* to where the JSON Reference is defined\n * and whose values are {@link module:JsonRefs~UnresolvedRefDetails}.\n *\n * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location\n *\n * @alias module:JsonRefs.findRefs\n *\n * @example\n * // Finding all valid references\n * var allRefs = JsonRefs.findRefs(obj);\n * // Finding all remote references\n * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});\n * // Finding all invalid references\n * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});\n */\nfunction findRefs (obj, options) {\n  var refs = {};\n\n  // Validate the provided document\n  if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n    throw new TypeError('obj must be an Array or an Object');\n  }\n\n  // Validate options\n  options = validateOptions(options, obj);\n\n  // Walk the document (or sub document) and find all JSON References\n  walk(findAncestors(obj, options.subDocPath),\n       findValue(obj, options.subDocPath),\n       clone(options.subDocPath),\n       function (ancestors, node, path) {\n         var processChildren = true;\n         var refDetails;\n\n         if (isRefLike(node)) {\n           // Pre-process the node when necessary\n           if (!isType(options.refPreProcessor, 'Undefined')) {\n             node = options.refPreProcessor(clone(node), path);\n           }\n\n           refDetails = getRefDetails(node);\n\n           // Post-process the reference details\n           if (!isType(options.refPostProcessor, 'Undefined')) {\n             refDetails = options.refPostProcessor(refDetails, path);\n           }\n\n           if (options.filter(refDetails, path)) {\n             refs[pathToPtr(path)] = refDetails;\n           }\n\n           // Whenever a JSON Reference has extra children, its children should not be processed.\n           //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3\n           if (getExtraRefKeys(node).length > 0) {\n             processChildren = false;\n           }\n         }\n\n         return processChildren;\n       });\n\n  return refs;\n}\n\n/**\n * Finds JSON References defined within the document at the provided location.\n *\n * This API is identical to {@link module:JsonRefs.findRefs} except this API will retrieve a remote document and then\n * return the result of {@link module:JsonRefs.findRefs} on the retrieved document.\n *\n * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.findRefsAt\n *\n * @example\n * // Example that only resolves references within a sub document\n * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {\n *     subDocPath: '#/definitions'\n *   })\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.value: The retrieved document\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction findRefsAt (location, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided location\n      if (!isType(location, 'String')) {\n        throw new TypeError('location must be a string');\n      }\n\n      // Validate options\n      options = validateOptions(options);\n\n      // Combine the location and the optional relative base\n      location = combineURIs(options.relativeBase, location);\n\n      return getRemoteDocument(location, options);\n    })\n    .then(function (res) {\n      var cacheEntry = clone(remoteCache[location]);\n      var cOptions = clone(options);\n      var uriDetails = parseURI(location);\n\n      if (isType(cacheEntry.refs, 'Undefined')) {\n        // Do not filter any references so the cache is complete\n        delete cOptions.filter;\n        delete cOptions.subDocPath;\n\n        cOptions.includeInvalid = true;\n\n        remoteCache[location].refs = findRefs(res, cOptions);\n      }\n\n      // Add the filter options back\n      if (!isType(options.filter, 'Undefined')) {\n        cOptions.filter = options.filter;\n      }\n\n      if (!isType(uriDetails.fragment, 'Undefined')) {\n        cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n      } else if (!isType(uriDetails.subDocPath, 'Undefined')) {\n        cOptions.subDocPath = options.subDocPath;\n      }\n\n      // This will use the cache so don't worry about calling it twice\n      return {\n        refs: findRefs(res, cOptions),\n        value: res\n      };\n    });\n\n  return allTasks;\n}\n\n/**\n * Returns detailed information about the JSON Reference.\n *\n * @param {object} obj - The JSON Reference definition\n *\n * @returns {module:JsonRefs~UnresolvedRefDetails} the detailed information\n *\n * @alias module:JsonRefs.getRefDetails\n */\nfunction getRefDetails (obj) {\n  var details = {\n    def: obj\n  };\n  var cacheKey;\n  var extraKeys;\n  var uriDetails;\n\n  try {\n    if (isRefLike(obj, true)) {\n      cacheKey = obj.$ref;\n      uriDetails = uriDetailsCache[cacheKey];\n\n      if (isType(uriDetails, 'Undefined')) {\n        uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);\n      }\n\n      details.uri = cacheKey;\n      details.uriDetails = uriDetails;\n\n      if (isType(uriDetails.error, 'Undefined')) {\n        details.type = getRefType(details);\n      } else {\n        details.error = details.uriDetails.error;\n        details.type = 'invalid';\n      }\n\n      // Identify warning\n      extraKeys = getExtraRefKeys(obj);\n\n      if (extraKeys.length > 0) {\n        details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');\n      }\n    } else {\n      details.type = 'invalid';\n    }\n  } catch (err) {\n    details.error = err.message;\n    details.type = 'invalid';\n  }\n\n  return details;\n}\n\n/**\n * Returns whether the argument represents a JSON Pointer.\n *\n * A string is a JSON Pointer if the following are all true:\n *\n *   * The string is of type `String`\n *   * The string must be empty, `#` or start with a `/` or `#/`\n *\n * @param {string} ptr - The string to check\n * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n * provided is invalid\n *\n * @returns {boolean} the result of the check\n *\n * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n *\n * @alias module:JsonRefs.isPtr\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @example\n * // Separating the different ways to invoke isPtr for demonstration purposes\n * if (isPtr(str)) {\n *   // Handle a valid JSON Pointer\n * } else {\n *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it\n *   try {\n *     isPtr(str, true);\n *   } catch (err) {\n *     // The error message contains the details as to why the provided value is not a JSON Pointer\n *   }\n * }\n */\nfunction isPtr (ptr, throwWithDetails) {\n  var valid = true;\n  var firstChar;\n\n  try {\n    if (isType(ptr, 'String')) {\n      if (ptr !== '') {\n        firstChar = ptr.charAt(0);\n\n        if (['#', '/'].indexOf(firstChar) === -1) {\n          throw new Error('ptr must start with a / or #/');\n        } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {\n          throw new Error('ptr must start with a / or #/');\n        } else if (ptr.match(badPtrTokenRegex)) {\n          throw new Error('ptr has invalid token(s)');\n        }\n      }\n    } else {\n      throw new Error('ptr is not a String');\n    }\n  } catch (err) {\n    if (throwWithDetails === true) {\n      throw err;\n    }\n\n    valid = false;\n  }\n\n  return valid;\n}\n\n/**\n * Returns whether the argument represents a JSON Reference.\n *\n * An object is a JSON Reference only if the following are all true:\n *\n *   * The object is of type `Object`\n *   * The object has a `$ref` property\n *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special\n *     characters.)*\n *\n * @param {object} obj - The object to check\n * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n * provided is invalid\n *\n * @returns {boolean} the result of the check\n *\n * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n *\n * @alias module:JsonRefs.isRef\n *\n * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}\n *\n * @example\n * // Separating the different ways to invoke isRef for demonstration purposes\n * if (isRef(obj)) {\n *   // Handle a valid JSON Reference\n * } else {\n *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it\n *   try {\n *     isRef(str, true);\n *   } catch (err) {\n *     // The error message contains the details as to why the provided value is not a JSON Reference\n *   }\n * }\n */\nfunction isRef (obj, throwWithDetails) {\n  return isRefLike(obj, throwWithDetails) && getRefDetails(obj, throwWithDetails).type !== 'invalid';\n}\n\n/**\n * Returns an array of path segments for the provided JSON Pointer.\n *\n * @param {string} ptr - The JSON Pointer\n *\n * @returns {string[]} the path segments\n *\n * @throws {Error} if the provided `ptr` argument is not a JSON Pointer\n *\n * @alias module:JsonRefs.pathFromPtr\n */\nfunction pathFromPtr (ptr) {\n  if (!isPtr(ptr)) {\n    throw new Error('ptr must be a JSON Pointer');\n  }\n\n  var segments = ptr.split('/');\n\n  // Remove the first segment\n  segments.shift();\n\n  return decodePath(segments);\n}\n\n/**\n * Returns a JSON Pointer for the provided array of path segments.\n *\n * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.\n *\n * @param {string[]} path - The array of path segments\n * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer\n *\n * @returns {string} the corresponding JSON Pointer\n *\n * @throws {Error} if the `path` argument is not an array\n *\n * @alias module:JsonRefs.pathToPtr\n */\nfunction pathToPtr (path, hashPrefix) {\n  if (!isType(path, 'Array')) {\n    throw new Error('path must be an Array');\n  }\n\n  // Encode each segment and return\n  return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + encodePath(path).join('/');\n}\n\n/**\n * Finds JSON References defined within the provided array/object and resolves them.\n *\n * @param {array|object} obj - The structure to find JSON References within\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~ResolvedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.resolveRefs\n *\n * @example\n * // Example that only resolves relative and remote references\n * JsonRefs.resolveRefs(swaggerObj, {\n *     filter: ['relative', 'remote']\n *   })\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.resolved: The document with the appropriate JSON References resolved\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction resolveRefs (obj, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided document\n      if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n        throw new TypeError('obj must be an Array or an Object');\n      }\n\n      // Validate options\n      options = validateOptions(options, obj);\n\n      // Clone the input so we do not alter it\n      obj = clone(obj);\n    })\n    .then(function () {\n      return findRefsRecursive(obj, options, [], [], {\n        documents: {},\n        refs: {}\n      });\n    })\n    .then(function (allRefs) {\n      var deferredRefs = {};\n      var refs = {};\n\n      function pathSorter (p1, p2) {\n        return pathFromPtr(p1).length - pathFromPtr(p2).length;\n      }\n\n      // Resolve all references with a known value\n      Object.keys(allRefs.refs).sort(pathSorter).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        // Record all direct references\n        if (!refDetails.indirect) {\n          refs[refPtr] = refDetails;\n        }\n\n        // Delete helper property\n        delete refDetails.indirect;\n\n        if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n          if (isType(refDetails.value, 'Undefined') && refDetails.circular) {\n            refDetails.value = refDetails.def;\n          }\n\n          // We defer processing all references without a value until later\n          if (isType(refDetails.value, 'Undefined')) {\n            deferredRefs[refPtr] = refDetails;\n          } else {\n            if (refPtr === '#') {\n              obj = refDetails.value;\n            } else {\n              setValue(obj, pathFromPtr(refPtr), refDetails.value);\n            }\n\n            // Delete helper property\n            delete refDetails.ancestorPtrs;\n          }\n        } else {\n          // Delete helper property\n          delete refDetails.ancestorPtrs;\n        }\n      });\n\n      // Resolve all deferred references\n      Object.keys(deferredRefs).forEach(function (refPtr) {\n        var refDetails = deferredRefs[refPtr];\n\n        // Attempt to resolve the value against all if its ancestors in order\n        refDetails.ancestorPtrs.forEach(function (ancestorPtr, index) {\n          if (isType(refDetails.value, 'Undefined')) {\n            try {\n              refDetails.value = findValue(allRefs.documents[ancestorPtr], pathFromPtr(refDetails.uri));\n\n              // Delete helper property\n              delete refDetails.ancestorPtrs;\n\n              setValue(obj, pathFromPtr(refPtr), refDetails.value);\n            } catch (err) {\n              if (index === refDetails.ancestorPtrs.length - 1) {\n                refDetails.error = err.message;\n                refDetails.missing = true;\n\n                // Delete helper property\n                delete refDetails.ancestorPtrs;\n              }\n            }\n          }\n        });\n      });\n\n      return {\n        refs: refs,\n        resolved: obj\n      };\n    });\n\n  return allTasks;\n}\n\n/**\n * Resolves JSON References defined within the document at the provided location.\n *\n * This API is identical to {@link module:JsonRefs.resolveRefs} except this API will retrieve a remote document and then\n * return the result of {@link module:JsonRefs.resolveRefs} on the retrieved document.\n *\n * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedResolvedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.resolveRefsAt\n *\n * @example\n * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references\n * JsonRefs.resolveRefsAt('./swagger.json')\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.resolved: The document with the appropriate JSON References resolved\n *      // res.value: The retrieved document\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction resolveRefsAt (location, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided location\n      if (!isType(location, 'String')) {\n        throw new TypeError('location must be a string');\n      }\n\n      // Validate options\n      options = validateOptions(options);\n\n      // Combine the location and the optional relative base\n      location = combineURIs(options.relativeBase, location);\n\n      return getRemoteDocument(location, options);\n    })\n    .then(function (res) {\n      var cOptions = clone(options);\n      var uriDetails = parseURI(location);\n\n      // Set the sub document path if necessary\n      if (!isType(uriDetails.fragment, 'Undefined')) {\n        cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n      }\n\n      // Update the relative base based on the retrieved location\n      cOptions.relativeBase = path.dirname(location);\n\n      return resolveRefs(res, cOptions)\n        .then(function (res2) {\n          return {\n            refs: res2.refs,\n            resolved: res2.resolved,\n            value: res\n          };\n        });\n    });\n\n  return allTasks;\n}\n\n/* Export the module members */\nmodule.exports.clearCache = clearCache;\nmodule.exports.decodePath = decodePath;\nmodule.exports.encodePath = encodePath;\nmodule.exports.findRefs = findRefs;\nmodule.exports.findRefsAt = findRefsAt;\nmodule.exports.getRefDetails = getRefDetails;\nmodule.exports.isPtr = isPtr;\nmodule.exports.isRef = isRef;\nmodule.exports.pathFromPtr = pathFromPtr;\nmodule.exports.pathToPtr = pathToPtr;\nmodule.exports.resolveRefs = resolveRefs;\nmodule.exports.resolveRefsAt = resolveRefsAt;\n\n\n\n// WEBPACK FOOTER //\n// index.js","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks['$' + event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/component-emitter/index.js","/*! Native Promise Only\n    v0.8.1 (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n\n(function UMD(name,context,definition){\n\t// special form of UMD for polyfilling across evironments\n\tcontext[name] = context[name] || definition();\n\tif (typeof module != \"undefined\" && module.exports) { module.exports = context[name]; }\n\telse if (typeof define == \"function\" && define.amd) { define(function $AMD$(){ return context[name]; }); }\n})(\"Promise\",typeof global != \"undefined\" ? global : this,function DEF(){\n\t/*jshint validthis:true */\n\t\"use strict\";\n\n\tvar builtInProp, cycle, scheduling_queue,\n\t\tToString = Object.prototype.toString,\n\t\ttimer = (typeof setImmediate != \"undefined\") ?\n\t\t\tfunction timer(fn) { return setImmediate(fn); } :\n\t\t\tsetTimeout\n\t;\n\n\t// dammit, IE8.\n\ttry {\n\t\tObject.defineProperty({},\"x\",{});\n\t\tbuiltInProp = function builtInProp(obj,name,val,config) {\n\t\t\treturn Object.defineProperty(obj,name,{\n\t\t\t\tvalue: val,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: config !== false\n\t\t\t});\n\t\t};\n\t}\n\tcatch (err) {\n\t\tbuiltInProp = function builtInProp(obj,name,val) {\n\t\t\tobj[name] = val;\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t// Note: using a queue instead of array for efficiency\n\tscheduling_queue = (function Queue() {\n\t\tvar first, last, item;\n\n\t\tfunction Item(fn,self) {\n\t\t\tthis.fn = fn;\n\t\t\tthis.self = self;\n\t\t\tthis.next = void 0;\n\t\t}\n\n\t\treturn {\n\t\t\tadd: function add(fn,self) {\n\t\t\t\titem = new Item(fn,self);\n\t\t\t\tif (last) {\n\t\t\t\t\tlast.next = item;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst = item;\n\t\t\t\t}\n\t\t\t\tlast = item;\n\t\t\t\titem = void 0;\n\t\t\t},\n\t\t\tdrain: function drain() {\n\t\t\t\tvar f = first;\n\t\t\t\tfirst = last = cycle = void 0;\n\n\t\t\t\twhile (f) {\n\t\t\t\t\tf.fn.call(f.self);\n\t\t\t\t\tf = f.next;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})();\n\n\tfunction schedule(fn,self) {\n\t\tscheduling_queue.add(fn,self);\n\t\tif (!cycle) {\n\t\t\tcycle = timer(scheduling_queue.drain);\n\t\t}\n\t}\n\n\t// promise duck typing\n\tfunction isThenable(o) {\n\t\tvar _then, o_type = typeof o;\n\n\t\tif (o != null &&\n\t\t\t(\n\t\t\t\to_type == \"object\" || o_type == \"function\"\n\t\t\t)\n\t\t) {\n\t\t\t_then = o.then;\n\t\t}\n\t\treturn typeof _then == \"function\" ? _then : false;\n\t}\n\n\tfunction notify() {\n\t\tfor (var i=0; i<this.chain.length; i++) {\n\t\t\tnotifyIsolated(\n\t\t\t\tthis,\n\t\t\t\t(this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n\t\t\t\tthis.chain[i]\n\t\t\t);\n\t\t}\n\t\tthis.chain.length = 0;\n\t}\n\n\t// NOTE: This is a separate function to isolate\n\t// the `try..catch` so that other code can be\n\t// optimized better\n\tfunction notifyIsolated(self,cb,chain) {\n\t\tvar ret, _then;\n\t\ttry {\n\t\t\tif (cb === false) {\n\t\t\t\tchain.reject(self.msg);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cb === true) {\n\t\t\t\t\tret = self.msg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = cb.call(void 0,self.msg);\n\t\t\t\t}\n\n\t\t\t\tif (ret === chain.promise) {\n\t\t\t\t\tchain.reject(TypeError(\"Promise-chain cycle\"));\n\t\t\t\t}\n\t\t\t\telse if (_then = isThenable(ret)) {\n\t\t\t\t\t_then.call(ret,chain.resolve,chain.reject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchain.resolve(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tchain.reject(err);\n\t\t}\n\t}\n\n\tfunction resolve(msg) {\n\t\tvar _then, self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_then = isThenable(msg)) {\n\t\t\t\tschedule(function(){\n\t\t\t\t\tvar def_wrapper = new MakeDefWrapper(self);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_then.call(msg,\n\t\t\t\t\t\t\tfunction $resolve$(){ resolve.apply(def_wrapper,arguments); },\n\t\t\t\t\t\t\tfunction $reject$(){ reject.apply(def_wrapper,arguments); }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\treject.call(def_wrapper,err);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself.msg = msg;\n\t\t\t\tself.state = 1;\n\t\t\t\tif (self.chain.length > 0) {\n\t\t\t\t\tschedule(notify,self);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(new MakeDefWrapper(self),err);\n\t\t}\n\t}\n\n\tfunction reject(msg) {\n\t\tvar self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\tself.msg = msg;\n\t\tself.state = 2;\n\t\tif (self.chain.length > 0) {\n\t\t\tschedule(notify,self);\n\t\t}\n\t}\n\n\tfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n\t\tfor (var idx=0; idx<arr.length; idx++) {\n\t\t\t(function IIFE(idx){\n\t\t\t\tConstructor.resolve(arr[idx])\n\t\t\t\t.then(\n\t\t\t\t\tfunction $resolver$(msg){\n\t\t\t\t\t\tresolver(idx,msg);\n\t\t\t\t\t},\n\t\t\t\t\trejecter\n\t\t\t\t);\n\t\t\t})(idx);\n\t\t}\n\t}\n\n\tfunction MakeDefWrapper(self) {\n\t\tthis.def = self;\n\t\tthis.triggered = false;\n\t}\n\n\tfunction MakeDef(self) {\n\t\tthis.promise = self;\n\t\tthis.state = 0;\n\t\tthis.triggered = false;\n\t\tthis.chain = [];\n\t\tthis.msg = void 0;\n\t}\n\n\tfunction Promise(executor) {\n\t\tif (typeof executor != \"function\") {\n\t\t\tthrow TypeError(\"Not a function\");\n\t\t}\n\n\t\tif (this.__NPO__ !== 0) {\n\t\t\tthrow TypeError(\"Not a promise\");\n\t\t}\n\n\t\t// instance shadowing the inherited \"brand\"\n\t\t// to signal an already \"initialized\" promise\n\t\tthis.__NPO__ = 1;\n\n\t\tvar def = new MakeDef(this);\n\n\t\tthis[\"then\"] = function then(success,failure) {\n\t\t\tvar o = {\n\t\t\t\tsuccess: typeof success == \"function\" ? success : true,\n\t\t\t\tfailure: typeof failure == \"function\" ? failure : false\n\t\t\t};\n\t\t\t// Note: `then(..)` itself can be borrowed to be used against\n\t\t\t// a different promise constructor for making the chained promise,\n\t\t\t// by substituting a different `this` binding.\n\t\t\to.promise = new this.constructor(function extractChain(resolve,reject) {\n\t\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t\t}\n\n\t\t\t\to.resolve = resolve;\n\t\t\t\to.reject = reject;\n\t\t\t});\n\t\t\tdef.chain.push(o);\n\n\t\t\tif (def.state !== 0) {\n\t\t\t\tschedule(notify,def);\n\t\t\t}\n\n\t\t\treturn o.promise;\n\t\t};\n\t\tthis[\"catch\"] = function $catch$(failure) {\n\t\t\treturn this.then(void 0,failure);\n\t\t};\n\n\t\ttry {\n\t\t\texecutor.call(\n\t\t\t\tvoid 0,\n\t\t\t\tfunction publicResolve(msg){\n\t\t\t\t\tresolve.call(def,msg);\n\t\t\t\t},\n\t\t\t\tfunction publicReject(msg) {\n\t\t\t\t\treject.call(def,msg);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(def,err);\n\t\t}\n\t}\n\n\tvar PromisePrototype = builtInProp({},\"constructor\",Promise,\n\t\t/*configurable=*/false\n\t);\n\n\t// Note: Android 4 cannot use `Object.defineProperty(..)` here\n\tPromise.prototype = PromisePrototype;\n\n\t// built-in \"brand\" to signal an \"uninitialized\" promise\n\tbuiltInProp(PromisePrototype,\"__NPO__\",0,\n\t\t/*configurable=*/false\n\t);\n\n\tbuiltInProp(Promise,\"resolve\",function Promise$resolve(msg) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\t// note: best \"isPromise\" check that's practical for now\n\t\tif (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n\t\t\treturn msg;\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tresolve(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"reject\",function Promise$reject(msg) {\n\t\treturn new this(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\treject(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"all\",function Promise$all(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\t\tif (arr.length === 0) {\n\t\t\treturn Constructor.resolve([]);\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tvar len = arr.length, msgs = Array(len), count = 0;\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg) {\n\t\t\t\tmsgs[idx] = msg;\n\t\t\t\tif (++count === len) {\n\t\t\t\t\tresolve(msgs);\n\t\t\t\t}\n\t\t\t},reject);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"race\",function Promise$race(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg){\n\t\t\t\tresolve(msg);\n\t\t\t},reject);\n\t\t});\n\t});\n\n\treturn Promise;\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/native-promise-only/lib/npo.src.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-browserify/index.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Utility that provides a single API for loading the content of a path/URL.\n *\n * @module PathLoader\n */\n\nvar supportedLoaders = {\n  file: require('./lib/loaders/file'),\n  http: require('./lib/loaders/http'),\n  https: require('./lib/loaders/http')\n};\nvar defaultLoader = typeof window === 'object' || typeof importScripts === 'function' ?\n      supportedLoaders.http :\n      supportedLoaders.file;\n\n// Load promises polyfill if necessary\n/* istanbul ignore if */\nif (typeof Promise === 'undefined') {\n  require('native-promise-only');\n}\n\nfunction getScheme (location) {\n  if (typeof location !== 'undefined') {\n    location = location.indexOf('://') === -1 ? '' : location.split('://')[0];\n  }\n\n  return location;\n}\n\n/**\n * Callback used to provide access to altering a remote request prior to the request being made.\n *\n * @typedef {function} PrepareRequestCallback\n *\n * @param {object} req - The Superagent request object\n * @param {string} location - The location being retrieved\n * @param {function} callback - First callback\n *\n * @alias module:PathLoader~PrepareRequestCallback\n */\n\n /**\n  * Callback used to provide access to processing the raw response of the request being made. *(HTTP loader only)*\n  *\n  * @typedef {function} ProcessResponseCallback\n  *\n  * @param {object} res - The Superagent response object *(For non-HTTP loaders, this object will be like the Superagent\n  * object in that it will have a `text` property whose value is the raw string value being processed.  This was done\n  * for consistency.)*\n  * @param {function} callback - Error-first callback\n  *\n  * @returns {*} the result of processing the responsexs\n  *\n  * @alias module:PathLoader~ProcessResponseCallback\n  */\n\nfunction getLoader (location) {\n  var scheme = getScheme(location);\n  var loader = supportedLoaders[scheme];\n\n  if (typeof loader === 'undefined') {\n    if (scheme === '') {\n      loader = defaultLoader;\n    } else {\n      throw new Error('Unsupported scheme: ' + scheme);\n    }\n  }\n\n  return loader;\n}\n\n/**\n * Loads a document at the provided location and returns a JavaScript object representation.\n *\n * @param {object} location - The location to the document\n * @param {object} [options] - The options\n * @param {string} [options.encoding='utf-8'] - The encoding to use when loading the file *(File loader only)*\n * @param {string} [options.method=get] - The HTTP method to use for the request *(HTTP loader only)*\n * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare the request\n * *(HTTP loader only)*\n * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n * response\n *\n * @returns {Promise} Always returns a promise even if there is a callback provided\n *\n * @example\n * // Example using Promises\n *\n * PathLoader\n *   .load('./package.json')\n *   .then(JSON.parse)\n *   .then(function (document) {\n *     console.log(document.name + ' (' + document.version + '): ' + document.description);\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example using options.prepareRequest to provide authentication details for a remotely secure URL\n *\n * PathLoader\n *   .load('https://api.github.com/repos/whitlockjc/path-loader', {\n *     prepareRequest: function (req, callback) {\n *       req.auth('my-username', 'my-password');\n *       callback(undefined, req);\n *     }\n *   })\n *   .then(JSON.parse)\n *   .then(function (document) {\n *     console.log(document.full_name + ': ' + document.description);\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example loading a YAML file\n *\n * PathLoader\n *   .load('/Users/not-you/projects/path-loader/.travis.yml')\n *   .then(YAML.safeLoad)\n *   .then(function (document) {\n *     console.log('path-loader uses the', document.language, 'language.');\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)\n *\n * PathLoader\n *   .load('/Users/not-you/projects/path-loader/.travis.yml', {\n *     processContent: function (res, callback) {\n *       callback(YAML.safeLoad(res.text));\n *     }\n *   })\n *   .then(function (document) {\n *     console.log('path-loader uses the', document.language, 'language.');\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n */\nmodule.exports.load = function (location, options) {\n  var allTasks = Promise.resolve();\n\n  // Default options to empty object\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n\n  // Validate arguments\n  allTasks = allTasks.then(function () {\n    if (typeof location === 'undefined') {\n      throw new TypeError('location is required');\n    } else if (typeof location !== 'string') {\n      throw new TypeError('location must be a string');\n    }\n\n    if (typeof options !== 'undefined') {\n      if (typeof options !== 'object') {\n        throw new TypeError('options must be an object');\n      } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {\n        throw new TypeError('options.processContent must be a function');\n      }\n    }\n  });\n\n  // Load the document from the provided location and process it\n  allTasks = allTasks\n    .then(function () {\n      return new Promise(function (resolve, reject) {\n        var loader = getLoader(location);\n\n        loader.load(location, options || {}, function (err, document) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(document);\n          }\n        });\n      });\n    })\n    .then(function (res) {\n      if (options.processContent) {\n        return new Promise(function (resolve, reject) {\n          // For consistency between file and http, always send an object with a 'text' property containing the raw\n          // string value being processed.\n          options.processContent(typeof res === 'object' ? res : {text: res}, function (err, processed) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(processed);\n            }\n          });\n        });\n      } else {\n        // If there was no content processor, we will assume that for all objects that it is a Superagent response\n        // and will return its `text` property value.  Otherwise, we will return the raw response.\n        return typeof res === 'object' ? res.text : res;\n      }\n    });\n\n  return allTasks;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/index.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar unsupportedError = new TypeError('The \\'file\\' scheme is not supported in the browser');\n\n/**\n * The file loader is not supported in the browser.\n *\n * @throws {error} the file loader is not supported in the browser\n */\nmodule.exports.getBase = function () {\n  throw unsupportedError;\n};\n\n/**\n * The file loader is not supported in the browser.\n */\nmodule.exports.load = function () {\n  var fn = arguments[arguments.length - 1];\n\n  if (typeof fn === 'function') {\n    fn(unsupportedError);\n  } else {\n    throw unsupportedError;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/lib/loaders/file-browser.js","/* eslint-env node, browser */\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar request = require('superagent');\n\nvar supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];\n\n/**\n * Loads a file from an http or https URL.\n *\n * @param {string} location - The document URL (If relative, location is relative to window.location.origin).\n * @param {object} options - The loader options\n * @param {string} [options.method=get] - The HTTP method to use for the request\n * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request\n * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n * response\n * @param {function} callback - The error-first callback\n */\nmodule.exports.load = function (location, options, callback) {\n  var realMethod = options.method ? options.method.toLowerCase() : 'get';\n  var err;\n  var realRequest;\n\n  function makeRequest (err, req) {\n    if (err) {\n      callback(err);\n    } else {\n      // buffer() is only available in Node.js\n      if (typeof req.buffer === 'function') {\n        req.buffer(true);\n      }\n\n      req\n        .end(function (err2, res) {\n          if (err2) {\n            callback(err2);\n          } else {\n            callback(undefined, res);\n          }\n        });\n    }\n  }\n\n  if (typeof options.method !== 'undefined') {\n    if (typeof options.method !== 'string') {\n      err = new TypeError('options.method must be a string');\n    } else if (supportedHttpMethods.indexOf(options.method) === -1) {\n      err = new TypeError('options.method must be one of the following: ' +\n        supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' +\n        supportedHttpMethods[supportedHttpMethods.length - 1]);\n    }\n  } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {\n    err = new TypeError('options.prepareRequest must be a function');\n  }\n\n  if (!err) {\n    realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);\n\n    if (options.prepareRequest) {\n      try {\n        options.prepareRequest(realRequest, makeRequest);\n      } catch (err2) {\n        callback(err2);\n      }\n    } else {\n      makeRequest(undefined, realRequest);\n    }\n  } else {\n    callback(err);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/lib/loaders/http.js","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n// WEBPACK FOOTER //\n// node_modules/process/browser.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/decode.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/encode.js","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/index.js","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n// WEBPACK FOOTER //\n// node_modules/reduce-component/index.js","'use strict';\nmodule.exports = function (str) {\n\tvar isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n\tvar hasNonAscii = /[^\\x00-\\x80]+/.test(str);\n\n\tif (isExtendedLengthPath || hasNonAscii) {\n\t\treturn str;\n\t}\n\n\treturn str.replace(/\\\\/g, '/');\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/slash/index.js","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\nvar requestBase = require('./request-base');\nvar isObject = require('./is-object');\n\n/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  root = this;\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Expose `request`.\n */\n\nvar request = module.exports = require('./request').bind(null, Request);\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pushEncodedKeyValuePair(pairs, key, obj[key]);\n        }\n      }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (Array.isArray(val)) {\n    return val.forEach(function(v) {\n      pushEncodedKeyValuePair(pairs, key, v);\n    });\n  }\n  pairs.push(encodeURIComponent(key)\n    + '=' + encodeURIComponent(val));\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      // issue #876: return the http status code if the response parsing fails\n      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter` and `requestBase`.\n */\n\nEmitter(Request.prototype);\nfor (var key in requestBase) {\n  Request.prototype[key] = requestBase[key];\n}\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set responseType to `val`. Presently valid responseTypes are 'blob' and \n * 'arraybuffer'.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (!options) {\n    options = {\n      type: 'basic'\n    }\n  }\n\n  switch (options.type) {\n    case 'basic':\n      var str = btoa(user + ':' + pass);\n      this.set('Authorization', 'Basic ' + str);\n    break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n    break;\n  }\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  this._getFormData().append(field, file, filename || file.name);\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this._header['content-type'];\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * @deprecated\n */\nResponse.prototype.parse = function serialize(fn){\n  if (root.console) {\n    console.warn(\"Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0\");\n  }\n  this.serialize(fn);\n  return this;\n};\n\nResponse.prototype.serialize = function serialize(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = 'download';\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  if (this.username && this.password) {\n    xhr.open(this.method, this.url, true, this.username, this.password);\n  } else {\n    xhr.open(this.method, this.url, true);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/client.js","/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null != obj && 'object' == typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/is-object.js","/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nexports.clearTimeout = function _clearTimeout(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Force given parser\n *\n * Sets the body parser no matter type.\n *\n * @param {Function}\n * @api public\n */\n\nexports.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nexports.timeout = function timeout(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nexports.then = function then(fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Allow for extension\n */\n\nexports.use = function use(fn) {\n  fn(this);\n  return this;\n}\n\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nexports.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nexports.getHeader = exports.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nexports.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nexports.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nexports.field = function(name, val) {\n  this._getFormData().append(name, val);\n  return this;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/request-base.js","// The node and browser modules expose versions of this with the\n// appropriate constructor function bound as first argument\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(RequestConstructor, method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new RequestConstructor('GET', method).end(url);\n  }\n\n  // url first\n  if (2 == arguments.length) {\n    return new RequestConstructor('GET', method);\n  }\n\n  return new RequestConstructor(method, url);\n}\n\nmodule.exports = request;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/request.js","/*! https://mths.be/punycode v1.3.2 by @mathias, modified for URI.js */\r\n\r\nvar punycode = (function () {\r\n\r\n\t/**\r\n\t * The `punycode` object.\r\n\t * @name punycode\r\n\t * @type Object\r\n\t */\r\n\tvar punycode,\r\n\r\n\t/** Highest positive signed 32-bit float value */\r\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n\t/** Bootstring parameters */\r\n\tbase = 36,\r\n\ttMin = 1,\r\n\ttMax = 26,\r\n\tskew = 38,\r\n\tdamp = 700,\r\n\tinitialBias = 72,\r\n\tinitialN = 128, // 0x80\r\n\tdelimiter = '-', // '\\x2D'\r\n\r\n\t/** Regular expressions */\r\n\tregexPunycode = /^xn--/,\r\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\r\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\r\n\r\n\t/** Error messages */\r\n\terrors = {\r\n\t\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t\t'invalid-input': 'Invalid input'\r\n\t},\r\n\r\n\t/** Convenience shortcuts */\r\n\tbaseMinusTMin = base - tMin,\r\n\tfloor = Math.floor,\r\n\tstringFromCharCode = String.fromCharCode,\r\n\r\n\t/** Temporary variable */\r\n\tkey;\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/**\r\n\t * A generic error utility function.\r\n\t * @private\r\n\t * @param {String} type The error type.\r\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n\t */\r\n\tfunction error(type) {\r\n\t\tthrow new RangeError(errors[type]);\r\n\t}\r\n\r\n\t/**\r\n\t * A generic `Array#map` utility function.\r\n\t * @private\r\n\t * @param {Array} array The array to iterate over.\r\n\t * @param {Function} callback The function that gets called for every array\r\n\t * item.\r\n\t * @returns {Array} A new array of values returned by the callback function.\r\n\t */\r\n\tfunction map(array, fn) {\r\n\t\tvar length = array.length;\r\n\t\tvar result = [];\r\n\t\twhile (length--) {\r\n\t\t\tresult[length] = fn(array[length]);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n\t * addresses.\r\n\t * @private\r\n\t * @param {String} domain The domain name or email address.\r\n\t * @param {Function} callback The function that gets called for every\r\n\t * character.\r\n\t * @returns {Array} A new string of characters returned by the callback\r\n\t * function.\r\n\t */\r\n\tfunction mapDomain(string, fn) {\r\n\t\tvar parts = string.split('@');\r\n\t\tvar result = '';\r\n\t\tif (parts.length > 1) {\r\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\t\tresult = parts[0] + '@';\r\n\t\t\tstring = parts[1];\r\n\t\t}\r\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\t\tstring = string.replace(regexSeparators, '\\x2E');\r\n\t\tvar labels = string.split('.');\r\n\t\tvar encoded = map(labels, fn).join('.');\r\n\t\treturn result + encoded;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an array containing the numeric code points of each Unicode\r\n\t * character in the string. While JavaScript uses UCS-2 internally,\r\n\t * this function will convert a pair of surrogate halves (each of which\r\n\t * UCS-2 exposes as separate characters) into a single code point,\r\n\t * matching UTF-16.\r\n\t * @see `punycode.ucs2.encode`\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode.ucs2\r\n\t * @name decode\r\n\t * @param {String} string The Unicode input string (UCS-2).\r\n\t * @returns {Array} The new array of code points.\r\n\t */\r\n\tfunction ucs2decode(string) {\r\n\t\tvar output = [],\r\n\t\t    counter = 0,\r\n\t\t    length = string.length,\r\n\t\t    value,\r\n\t\t    extra;\r\n\t\twhile (counter < length) {\r\n\t\t\tvalue = string.charCodeAt(counter++);\r\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t\t// high surrogate, and there is a next character\r\n\t\t\t\textra = string.charCodeAt(counter++);\r\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\r\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\r\n\t\t\t\t\toutput.push(value);\r\n\t\t\t\t\tcounter--;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a string based on an array of numeric code points.\r\n\t * @see `punycode.ucs2.decode`\r\n\t * @memberOf punycode.ucs2\r\n\t * @name encode\r\n\t * @param {Array} codePoints The array of numeric code points.\r\n\t * @returns {String} The new Unicode string (UCS-2).\r\n\t */\r\n\tfunction ucs2encode(array) {\r\n\t\treturn map(array, function(value) {\r\n\t\t\tvar output = '';\r\n\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\tvalue -= 0x10000;\r\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\r\n\t\t\t}\r\n\t\t\toutput += stringFromCharCode(value);\r\n\t\t\treturn output;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a basic code point into a digit/integer.\r\n\t * @see `digitToBasic()`\r\n\t * @private\r\n\t * @param {Number} codePoint The basic numeric code point value.\r\n\t * @returns {Number} The numeric value of a basic code point (for use in\r\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\r\n\t * the code point does not represent a value.\r\n\t */\r\n\tfunction basicToDigit(codePoint) {\r\n\t\tif (codePoint - 48 < 10) {\r\n\t\t\treturn codePoint - 22;\r\n\t\t}\r\n\t\tif (codePoint - 65 < 26) {\r\n\t\t\treturn codePoint - 65;\r\n\t\t}\r\n\t\tif (codePoint - 97 < 26) {\r\n\t\t\treturn codePoint - 97;\r\n\t\t}\r\n\t\treturn base;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a digit/integer into a basic code point.\r\n\t * @see `basicToDigit()`\r\n\t * @private\r\n\t * @param {Number} digit The numeric value of a basic code point.\r\n\t * @returns {Number} The basic code point whose value (when used for\r\n\t * representing integers) is `digit`, which needs to be in the range\r\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n\t * used; else, the lowercase form is used. The behavior is undefined\r\n\t * if `flag` is non-zero and `digit` has no uppercase form.\r\n\t */\r\n\tfunction digitToBasic(digit, flag) {\r\n\t\t//  0..25 map to ASCII a..z or A..Z\r\n\t\t// 26..35 map to ASCII 0..9\r\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\r\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\r\n\t * @private\r\n\t */\r\n\tfunction adapt(delta, numPoints, firstTime) {\r\n\t\tvar k = 0;\r\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\t\tdelta += floor(delta / numPoints);\r\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\t\tdelta = floor(delta / baseMinusTMin);\r\n\t\t}\r\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycode string of ASCII-only symbols.\r\n\t * @returns {String} The resulting string of Unicode symbols.\r\n\t */\r\n\tfunction decode(input) {\r\n\t\t// Don't use UCS-2\r\n\t\tvar output = [],\r\n\t\t    inputLength = input.length,\r\n\t\t    out,\r\n\t\t    i = 0,\r\n\t\t    n = initialN,\r\n\t\t    bias = initialBias,\r\n\t\t    basic,\r\n\t\t    j,\r\n\t\t    index,\r\n\t\t    oldi,\r\n\t\t    w,\r\n\t\t    k,\r\n\t\t    digit,\r\n\t\t    t,\r\n\t\t    /** Cached calculation results */\r\n\t\t    baseMinusT;\r\n\r\n\t\t// Handle the basic code points: let `basic` be the number of input code\r\n\t\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t\t// the first basic code points to the output.\r\n\r\n\t\tbasic = input.lastIndexOf(delimiter);\r\n\t\tif (basic < 0) {\r\n\t\t\tbasic = 0;\r\n\t\t}\r\n\r\n\t\tfor (j = 0; j < basic; ++j) {\r\n\t\t\t// if it's not a basic code point\r\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\t\terror('not-basic');\r\n\t\t\t}\r\n\t\t\toutput.push(input.charCodeAt(j));\r\n\t\t}\r\n\r\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t\t// points were copied; start at the beginning otherwise.\r\n\r\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t\t// `index` is the index of the next character to be consumed.\r\n\t\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t\t// value at the end to obtain `delta`.\r\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\t\tif (index >= inputLength) {\r\n\t\t\t\t\terror('invalid-input');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti += digit * w;\r\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\t\tif (digit < t) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tw *= baseMinusT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tout = output.length + 1;\r\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tn += floor(i / out);\r\n\t\t\ti %= out;\r\n\r\n\t\t\t// Insert `n` at position `i` of the output\r\n\t\t\toutput.splice(i++, 0, n);\r\n\r\n\t\t}\r\n\r\n\t\treturn ucs2encode(output);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n\t * Punycode string of ASCII-only symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The string of Unicode symbols.\r\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n\t */\r\n\tfunction encode(input) {\r\n\t\tvar n,\r\n\t\t    delta,\r\n\t\t    handledCPCount,\r\n\t\t    basicLength,\r\n\t\t    bias,\r\n\t\t    j,\r\n\t\t    m,\r\n\t\t    q,\r\n\t\t    k,\r\n\t\t    t,\r\n\t\t    currentValue,\r\n\t\t    output = [],\r\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\r\n\t\t    inputLength,\r\n\t\t    /** Cached calculation results */\r\n\t\t    handledCPCountPlusOne,\r\n\t\t    baseMinusT,\r\n\t\t    qMinusT;\r\n\r\n\t\t// Convert the input in UCS-2 to Unicode\r\n\t\tinput = ucs2decode(input);\r\n\r\n\t\t// Cache the length\r\n\t\tinputLength = input.length;\r\n\r\n\t\t// Initialize the state\r\n\t\tn = initialN;\r\n\t\tdelta = 0;\r\n\t\tbias = initialBias;\r\n\r\n\t\t// Handle the basic code points\r\n\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\tcurrentValue = input[j];\r\n\t\t\tif (currentValue < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thandledCPCount = basicLength = output.length;\r\n\r\n\t\t// `handledCPCount` is the number of code points that have been handled;\r\n\t\t// `basicLength` is the number of basic code points.\r\n\r\n\t\t// Finish the basic string - if it is not empty - with a delimiter\r\n\t\tif (basicLength) {\r\n\t\t\toutput.push(delimiter);\r\n\t\t}\r\n\r\n\t\t// Main encoding loop:\r\n\t\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t\t// larger one:\r\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow\r\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\r\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\t\tn = m;\r\n\r\n\t\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\r\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\r\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\r\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tqMinusT = q - t;\r\n\t\t\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t++delta;\r\n\t\t\t++n;\r\n\r\n\t\t}\r\n\t\treturn output.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string representing a domain name or an email address\r\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n\t * it doesn't matter if you call it on a string that has already been\r\n\t * converted to Unicode.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycoded domain name or email address to\r\n\t * convert to Unicode.\r\n\t * @returns {String} The Unicode representation of the given Punycode\r\n\t * string.\r\n\t */\r\n\tfunction toUnicode(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexPunycode.test(string)\r\n\t\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Unicode string representing a domain name or an email address to\r\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n\t * i.e. it doesn't matter if you call it with a domain that's already in\r\n\t * ASCII.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The domain name or email address to convert, as a\r\n\t * Unicode string.\r\n\t * @returns {String} The Punycode representation of the given domain name or\r\n\t * email address.\r\n\t */\r\n\tfunction toASCII(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexNonASCII.test(string)\r\n\t\t\t\t? 'xn--' + encode(string)\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/** Define the public API */\r\n\tpunycode = {\r\n\t\t/**\r\n\t\t * A string representing the current Punycode.js version number.\r\n\t\t * @memberOf punycode\r\n\t\t * @type String\r\n\t\t */\r\n\t\tversion: '1.3.2',\r\n\t\t/**\r\n\t\t * An object of methods to convert from JavaScript's internal character\r\n\t\t * representation (UCS-2) to Unicode code points, and back.\r\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t\t * @memberOf punycode\r\n\t\t * @type Object\r\n\t\t */\r\n\t\tucs2: {\r\n\t\t\tdecode: ucs2decode,\r\n\t\t\tencode: ucs2encode\r\n\t\t},\r\n\t\tdecode: decode,\r\n\t\tencode: encode,\r\n\t\ttoASCII: toASCII,\r\n\t\ttoUnicode: toUnicode\r\n\t};\r\n\r\n\treturn punycode;\r\n}());\r\n\r\nif (typeof COMPILED === \"undefined\" && typeof module !== \"undefined\") module.exports = punycode;\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/punycode.js","///<reference path=\"commonjs.d.ts\"/>\r\nrequire(\"./schemes/http\");\r\nrequire(\"./schemes/urn\");\r\nrequire(\"./schemes/mailto\");\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\r\n    var URI = require(\"../uri\");\r\nURI.SCHEMES[\"http\"] = URI.SCHEMES[\"https\"] = {\r\n    domainHost: true,\r\n    parse: function (components, options) {\r\n        //report missing host\r\n        if (!components.host) {\r\n            components.error = components.error || \"HTTP URIs must have a host.\";\r\n        }\r\n        return components;\r\n    },\r\n    serialize: function (components, options) {\r\n        //normalize the default port\r\n        if (components.port === (String(components.scheme).toLowerCase() !== \"https\" ? 80 : 443) || components.port === \"\") {\r\n            components.port = undefined;\r\n        }\r\n        //normalize the empty path\r\n        if (!components.path) {\r\n            components.path = \"/\";\r\n        }\r\n        //NOTE: We do not parse query strings for HTTP URIs\r\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\r\n        //and not the HTTP spec. \r\n        return components;\r\n    }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/http.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\") {\r\n    var URI = require(\"../uri\"), punycode = require(\"../punycode\");\r\n}\r\n(function () {\r\n    function merge() {\r\n        var sets = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sets[_i - 0] = arguments[_i];\r\n        }\r\n        if (sets.length > 1) {\r\n            sets[0] = sets[0].slice(0, -1);\r\n            var xl = sets.length - 1;\r\n            for (var x = 1; x < xl; ++x) {\r\n                sets[x] = sets[x].slice(1, -1);\r\n            }\r\n            sets[xl] = sets[xl].slice(1);\r\n            return sets.join('');\r\n        }\r\n        else {\r\n            return sets[0];\r\n        }\r\n    }\r\n    function subexp(str) {\r\n        return \"(?:\" + str + \")\";\r\n    }\r\n    var O = {}, isIRI = URI.IRI_SUPPORT, \r\n    //RFC 3986\r\n    UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\", HEXDIG$$ = \"[0-9A-Fa-f]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), \r\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; = \r\n    //ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\",\r\n    //WSP$$ = \"[\\\\x20\\\\x09]\",\r\n    //OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\",  //(%d1-8 / %d11-12 / %d14-31 / %d127)\r\n    //QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$),  //%d33 / %d35-91 / %d93-126 / obs-qtext\r\n    //VCHAR$$ = \"[\\\\x21-\\\\x7E]\",\r\n    //WSP$$ = \"[\\\\x20\\\\x09]\",\r\n    //OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$)),  //%d0 / CR / LF / obs-qtext\r\n    //FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\"),\r\n    //QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$),\r\n    //QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"'),\r\n    ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\", QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\", VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\"), DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\"), QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$), QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$), QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"'), \r\n    //RFC 6068\r\n    DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\", SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\", QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$), DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\"), LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$), ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$), TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\"), HFNAME$ = subexp(QCHAR$ + \"*\"), HFVALUE$ = HFNAME$, HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$), HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\"), HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$), MAILTO_URI = URI.VALIDATE_SUPPORT && new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\"), UNRESERVED = new RegExp(UNRESERVED$$, \"g\"), PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\"), NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\"), NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\"), NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\"), NOT_HFVALUE = NOT_HFNAME, TO = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + TO$ + \"$\"), HFIELDS = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + HFIELDS2$ + \"$\");\r\n    function toUpperCase(str) {\r\n        return str.toUpperCase();\r\n    }\r\n    function decodeUnreserved(str) {\r\n        var decStr = URI.pctDecChars(str);\r\n        return (!decStr.match(UNRESERVED) ? str : decStr);\r\n    }\r\n    function toArray(obj) {\r\n        return obj !== undefined && obj !== null ? (obj instanceof Array && !obj.callee ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\r\n    }\r\n    URI.SCHEMES[\"mailto\"] = {\r\n        parse: function (components, options) {\r\n            if (URI.VALIDATE_SUPPORT && !components.error) {\r\n                if (components.path && !TO.test(components.path)) {\r\n                    components.error = \"Email address is not valid\";\r\n                }\r\n                else if (components.query && !HFIELDS.test(components.query)) {\r\n                    components.error = \"Header fields are invalid\";\r\n                }\r\n            }\r\n            var to = components.to = (components.path ? components.path.split(\",\") : []);\r\n            components.path = undefined;\r\n            if (components.query) {\r\n                var unknownHeaders = false, headers = {};\r\n                var hfields = components.query.split(\"&\");\r\n                for (var x = 0, xl = hfields.length; x < xl; ++x) {\r\n                    var hfield = hfields[x].split(\"=\");\r\n                    switch (hfield[0]) {\r\n                        case \"to\":\r\n                            var toAddrs = hfield[1].split(\",\");\r\n                            for (var x_1 = 0, xl_1 = toAddrs.length; x_1 < xl_1; ++x_1) {\r\n                                to.push(toAddrs[x_1]);\r\n                            }\r\n                            break;\r\n                        case \"subject\":\r\n                            components.subject = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                        case \"body\":\r\n                            components.body = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                        default:\r\n                            unknownHeaders = true;\r\n                            headers[URI.unescapeComponent(hfield[0], options)] = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                    }\r\n                }\r\n                if (unknownHeaders)\r\n                    components.headers = headers;\r\n            }\r\n            components.query = undefined;\r\n            for (var x = 0, xl = to.length; x < xl; ++x) {\r\n                var addr = to[x].split(\"@\");\r\n                addr[0] = URI.unescapeComponent(addr[0]);\r\n                if (typeof punycode !== \"undefined\" && !options.unicodeSupport) {\r\n                    //convert Unicode IDN -> ASCII IDN\r\n                    try {\r\n                        addr[1] = punycode.toASCII(URI.unescapeComponent(addr[1], options).toLowerCase());\r\n                    }\r\n                    catch (e) {\r\n                        components.error = components.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\r\n                    }\r\n                }\r\n                else {\r\n                    addr[1] = URI.unescapeComponent(addr[1], options).toLowerCase();\r\n                }\r\n                to[x] = addr.join(\"@\");\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            var to = toArray(components.to);\r\n            if (to) {\r\n                for (var x = 0, xl = to.length; x < xl; ++x) {\r\n                    var toAddr = String(to[x]);\r\n                    var atIdx = toAddr.lastIndexOf(\"@\");\r\n                    var localPart = toAddr.slice(0, atIdx);\r\n                    var domain = toAddr.slice(atIdx + 1);\r\n                    localPart = localPart.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, URI.pctEncChar);\r\n                    if (typeof punycode !== \"undefined\") {\r\n                        //convert IDN via punycode\r\n                        try {\r\n                            domain = (!options.iri ? punycode.toASCII(URI.unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\r\n                        }\r\n                        catch (e) {\r\n                            components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n                        }\r\n                    }\r\n                    else {\r\n                        domain = domain.replace(PCT_ENCODED, decodeUnreserved).toLowerCase().replace(PCT_ENCODED, toUpperCase).replace(NOT_DOMAIN, URI.pctEncChar);\r\n                    }\r\n                    to[x] = localPart + \"@\" + domain;\r\n                }\r\n                components.path = to.join(\",\");\r\n            }\r\n            var headers = components.headers = components.headers || {};\r\n            if (components.subject)\r\n                headers[\"subject\"] = components.subject;\r\n            if (components.body)\r\n                headers[\"body\"] = components.body;\r\n            var fields = [];\r\n            for (var name_1 in headers) {\r\n                if (headers[name_1] !== O[name_1]) {\r\n                    fields.push(name_1.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, URI.pctEncChar) +\r\n                        \"=\" +\r\n                        headers[name_1].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, URI.pctEncChar));\r\n                }\r\n            }\r\n            if (fields.length) {\r\n                components.query = fields.join(\"&\");\r\n            }\r\n            return components;\r\n        }\r\n    };\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/mailto.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\r\n    var URI = require(\"../uri\");\r\n(function () {\r\n    var pctEncChar = URI.pctEncChar, NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\", PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\", TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\", NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\", URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\"), URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\"), URN_PARSE = /^([^\\:]+)\\:(.*)/, URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g, UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\r\n    //RFC 2141\r\n    URI.SCHEMES[\"urn\"] = {\r\n        parse: function (components, options) {\r\n            var matches = components.path.match(URN_PATH), scheme, schemeHandler;\r\n            if (!matches) {\r\n                if (!options.tolerant) {\r\n                    components.error = components.error || \"URN is not strictly valid.\";\r\n                }\r\n                matches = components.path.match(URN_PARSE);\r\n            }\r\n            if (matches) {\r\n                scheme = \"urn:\" + matches[1].toLowerCase();\r\n                schemeHandler = URI.SCHEMES[scheme];\r\n                //in order to serialize properly, \r\n                //every URN must have a serializer that calls the URN serializer \r\n                if (!schemeHandler) {\r\n                    //create fake scheme handler\r\n                    schemeHandler = URI.SCHEMES[scheme] = {\r\n                        parse: function (components, options) {\r\n                            return components;\r\n                        },\r\n                        serialize: URI.SCHEMES[\"urn\"].serialize\r\n                    };\r\n                }\r\n                components.scheme = scheme;\r\n                components.path = matches[2];\r\n                components = schemeHandler.parse(components, options);\r\n            }\r\n            else {\r\n                components.error = components.error || \"URN can not be parsed.\";\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            var scheme = components.scheme || options.scheme, matches;\r\n            if (scheme && scheme !== \"urn\") {\r\n                var matches = scheme.match(URN_SCHEME);\r\n                if (!matches) {\r\n                    matches = [\"urn:\" + scheme, scheme];\r\n                }\r\n                components.scheme = \"urn\";\r\n                components.path = matches[1] + \":\" + (components.path ? components.path.replace(URN_EXCLUDED, pctEncChar) : \"\");\r\n            }\r\n            return components;\r\n        }\r\n    };\r\n    //RFC 4122\r\n    URI.SCHEMES[\"urn:uuid\"] = {\r\n        parse: function (components, options) {\r\n            if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\r\n                components.error = components.error || \"UUID is not valid.\";\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            //ensure UUID is valid\r\n            if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\r\n                //invalid UUIDs can not have this scheme\r\n                components.scheme = undefined;\r\n            }\r\n            else {\r\n                //normalize UUID\r\n                components.path = (components.path || \"\").toLowerCase();\r\n            }\r\n            return URI.SCHEMES[\"urn\"].serialize(components, options);\r\n        }\r\n    };\r\n}());\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/urn.js","/**\r\n * URI.js\r\n *\r\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\r\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n * @version 2.0.0\r\n * @see http://github.com/garycourt/uri-js\r\n * @license URI.js v2.0.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js\r\n */\r\n/**\r\n * Copyright 2011 Gary Court. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification, are\r\n * permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this list of\r\n *       conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n *       of conditions and the following disclaimer in the documentation and/or other materials\r\n *       provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * The views and conclusions contained in the software and documentation are those of the\r\n * authors and should not be interpreted as representing official policies, either expressed\r\n * or implied, of Gary Court.\r\n */\r\n///<reference path=\"punycode.d.ts\"/>\r\n///<reference path=\"commonjs.d.ts\"/>\r\n/**\r\n * Compiler switch for indicating code is compiled\r\n * @define {boolean}\r\n */\r\nvar COMPILED = false;\r\n/**\r\n * Compiler switch for supporting IRI URIs\r\n * @define {boolean}\r\n */\r\nvar URI__IRI_SUPPORT = true;\r\n/**\r\n * Compiler switch for supporting URI validation\r\n * @define {boolean}\r\n */\r\nvar URI__VALIDATE_SUPPORT = true;\r\nvar URI = (function () {\r\n    function merge() {\r\n        var sets = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sets[_i - 0] = arguments[_i];\r\n        }\r\n        if (sets.length > 1) {\r\n            sets[0] = sets[0].slice(0, -1);\r\n            var xl = sets.length - 1;\r\n            for (var x = 1; x < xl; ++x) {\r\n                sets[x] = sets[x].slice(1, -1);\r\n            }\r\n            sets[xl] = sets[xl].slice(1);\r\n            return sets.join('');\r\n        }\r\n        else {\r\n            return sets[0];\r\n        }\r\n    }\r\n    function subexp(str) {\r\n        return \"(?:\" + str + \")\";\r\n    }\r\n    function buildExps(isIRI) {\r\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS$ = subexp(merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IPVFUTURE$ = subexp(\"v\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\r\n        return {\r\n            URI_REF: URI__VALIDATE_SUPPORT && new RegExp(\"(\" + GENERIC_REF$ + \")|(\" + RELATIVE_REF$ + \")\"),\r\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\r\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_HOST: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\r\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\r\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\r\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\r\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\")\r\n        };\r\n    }\r\n    var URI_PROTOCOL = buildExps(false), IRI_PROTOCOL = URI__IRI_SUPPORT ? buildExps(true) : undefined, URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?([^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n)*))?/i, RDS1 = /^\\.\\.?\\//, RDS2 = /^\\/\\.(\\/|$)/, RDS3 = /^\\/\\.\\.(\\/|$)/, RDS4 = /^\\.\\.?$/, RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/, NO_MATCH_IS_UNDEFINED = (\"\").match(/(){0}/)[1] === undefined;\r\n    function pctEncChar(chr) {\r\n        var c = chr.charCodeAt(0), e;\r\n        if (c < 16)\r\n            e = \"%0\" + c.toString(16).toUpperCase();\r\n        else if (c < 128)\r\n            e = \"%\" + c.toString(16).toUpperCase();\r\n        else if (c < 2048)\r\n            e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\r\n        else\r\n            e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\r\n        return e;\r\n    }\r\n    function pctDecChars(str) {\r\n        var newStr = \"\", i = 0, il = str.length, c, c2, c3;\r\n        while (i < il) {\r\n            c = parseInt(str.substr(i + 1, 2), 16);\r\n            if (c < 128) {\r\n                newStr += String.fromCharCode(c);\r\n                i += 3;\r\n            }\r\n            else if (c >= 194 && c < 224) {\r\n                if ((il - i) >= 6) {\r\n                    c2 = parseInt(str.substr(i + 4, 2), 16);\r\n                    newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\r\n                }\r\n                else {\r\n                    newStr += str.substr(i, 6);\r\n                }\r\n                i += 6;\r\n            }\r\n            else if (c >= 224) {\r\n                if ((il - i) >= 9) {\r\n                    c2 = parseInt(str.substr(i + 4, 2), 16);\r\n                    c3 = parseInt(str.substr(i + 7, 2), 16);\r\n                    newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n                }\r\n                else {\r\n                    newStr += str.substr(i, 9);\r\n                }\r\n                i += 9;\r\n            }\r\n            else {\r\n                newStr += str.substr(i, 3);\r\n                i += 3;\r\n            }\r\n        }\r\n        return newStr;\r\n    }\r\n    function typeOf(o) {\r\n        return o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\r\n    }\r\n    function toUpperCase(str) {\r\n        return str.toUpperCase();\r\n    }\r\n    var SCHEMES = {};\r\n    function _normalizeComponentEncoding(components, protocol) {\r\n        function decodeUnreserved(str) {\r\n            var decStr = pctDecChars(str);\r\n            return (!decStr.match(protocol.UNRESERVED) ? str : decStr);\r\n        }\r\n        if (components.scheme)\r\n            components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\r\n        if (components.userinfo !== undefined)\r\n            components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.host !== undefined)\r\n            components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.path !== undefined)\r\n            components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.query !== undefined)\r\n            components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.fragment !== undefined)\r\n            components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        return components;\r\n    }\r\n    ;\r\n    function parse(uriString, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var protocol = (URI__IRI_SUPPORT && options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL), matches, parseError = false, components = {}, schemeHandler;\r\n        if (options.reference === \"suffix\")\r\n            uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\r\n        if (URI__VALIDATE_SUPPORT) {\r\n            matches = uriString.match(protocol.URI_REF);\r\n            if (matches) {\r\n                if (matches[1]) {\r\n                    //generic URI\r\n                    matches = matches.slice(1, 10);\r\n                }\r\n                else {\r\n                    //relative URI\r\n                    matches = matches.slice(10, 19);\r\n                }\r\n            }\r\n            if (!matches) {\r\n                parseError = true;\r\n                if (!options.tolerant)\r\n                    components.error = components.error || \"URI is not strictly valid.\";\r\n                matches = uriString.match(URI_PARSE);\r\n            }\r\n        }\r\n        else {\r\n            matches = uriString.match(URI_PARSE);\r\n        }\r\n        if (matches) {\r\n            if (NO_MATCH_IS_UNDEFINED) {\r\n                //store each component\r\n                components.scheme = matches[1];\r\n                //components.authority = matches[2];\r\n                components.userinfo = matches[3];\r\n                components.host = matches[4];\r\n                components.port = parseInt(matches[5], 10);\r\n                components.path = matches[6] || \"\";\r\n                components.query = matches[7];\r\n                components.fragment = matches[8];\r\n                //fix port number\r\n                if (isNaN(components.port)) {\r\n                    components.port = matches[5];\r\n                }\r\n            }\r\n            else {\r\n                //store each component\r\n                components.scheme = matches[1] || undefined;\r\n                //components.authority = (uriString.indexOf(\"//\") !== -1 ? matches[2] : undefined);\r\n                components.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\r\n                components.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\r\n                components.port = parseInt(matches[5], 10);\r\n                components.path = matches[6] || \"\";\r\n                components.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\r\n                components.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\r\n                //fix port number\r\n                if (isNaN(components.port)) {\r\n                    components.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\r\n                }\r\n            }\r\n            //determine reference type\r\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\r\n                components.reference = \"same-document\";\r\n            }\r\n            else if (components.scheme === undefined) {\r\n                components.reference = \"relative\";\r\n            }\r\n            else if (components.fragment === undefined) {\r\n                components.reference = \"absolute\";\r\n            }\r\n            else {\r\n                components.reference = \"uri\";\r\n            }\r\n            //check for reference errors\r\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\r\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\r\n            }\r\n            //find scheme handler\r\n            schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n            //check if scheme can't handle IRIs\r\n            if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && !options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\r\n                //if host component is a domain name\r\n                if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\r\n                    //convert Unicode IDN -> ASCII IDN\r\n                    try {\r\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\r\n                    }\r\n                    catch (e) {\r\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\r\n                    }\r\n                }\r\n                //convert IRI -> URI\r\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\r\n            }\r\n            else {\r\n                //normalize encodings\r\n                _normalizeComponentEncoding(components, protocol);\r\n            }\r\n            //perform scheme specific parsing\r\n            if (schemeHandler && schemeHandler.parse) {\r\n                schemeHandler.parse(components, options);\r\n            }\r\n        }\r\n        else {\r\n            parseError = true;\r\n            components.error = components.error || \"URI can not be parsed.\";\r\n        }\r\n        return components;\r\n    }\r\n    ;\r\n    function _recomposeAuthority(components, options) {\r\n        var uriTokens = [];\r\n        if (components.userinfo !== undefined) {\r\n            uriTokens.push(components.userinfo);\r\n            uriTokens.push(\"@\");\r\n        }\r\n        if (components.host !== undefined) {\r\n            uriTokens.push(components.host);\r\n        }\r\n        if (typeof components.port === \"number\") {\r\n            uriTokens.push(\":\");\r\n            uriTokens.push(components.port.toString(10));\r\n        }\r\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\r\n    }\r\n    ;\r\n    function removeDotSegments(input) {\r\n        var output = [], s;\r\n        while (input.length) {\r\n            if (input.match(RDS1)) {\r\n                input = input.replace(RDS1, \"\");\r\n            }\r\n            else if (input.match(RDS2)) {\r\n                input = input.replace(RDS2, \"/\");\r\n            }\r\n            else if (input.match(RDS3)) {\r\n                input = input.replace(RDS3, \"/\");\r\n                output.pop();\r\n            }\r\n            else if (input === \".\" || input === \"..\") {\r\n                input = \"\";\r\n            }\r\n            else {\r\n                s = input.match(RDS5)[0];\r\n                input = input.slice(s.length);\r\n                output.push(s);\r\n            }\r\n        }\r\n        return output.join(\"\");\r\n    }\r\n    ;\r\n    function serialize(components, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var protocol = (URI__IRI_SUPPORT && options.iri ? IRI_PROTOCOL : URI_PROTOCOL), uriTokens = [], schemeHandler, authority, s;\r\n        //find scheme handler\r\n        schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n        //perform scheme specific serialization\r\n        if (schemeHandler && schemeHandler.serialize)\r\n            schemeHandler.serialize(components, options);\r\n        //if host component is a domain name\r\n        if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\r\n            //convert IDN via punycode\r\n            try {\r\n                components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\r\n            }\r\n            catch (e) {\r\n                components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n            }\r\n        }\r\n        //normalize encoding\r\n        _normalizeComponentEncoding(components, protocol);\r\n        if (options.reference !== \"suffix\" && components.scheme) {\r\n            uriTokens.push(components.scheme);\r\n            uriTokens.push(\":\");\r\n        }\r\n        authority = _recomposeAuthority(components, options);\r\n        if (authority !== undefined) {\r\n            if (options.reference !== \"suffix\") {\r\n                uriTokens.push(\"//\");\r\n            }\r\n            uriTokens.push(authority);\r\n            if (components.path && components.path.charAt(0) !== \"/\") {\r\n                uriTokens.push(\"/\");\r\n            }\r\n        }\r\n        if (components.path !== undefined) {\r\n            s = components.path;\r\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\r\n                s = removeDotSegments(s);\r\n            }\r\n            if (authority === undefined) {\r\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\r\n            }\r\n            uriTokens.push(s);\r\n        }\r\n        if (components.query !== undefined) {\r\n            uriTokens.push(\"?\");\r\n            uriTokens.push(components.query);\r\n        }\r\n        if (components.fragment !== undefined) {\r\n            uriTokens.push(\"#\");\r\n            uriTokens.push(components.fragment);\r\n        }\r\n        return uriTokens.join(''); //merge tokens into a string\r\n    }\r\n    ;\r\n    function resolveComponents(base, relative, options, skipNormalization) {\r\n        if (options === void 0) { options = {}; }\r\n        var target = {};\r\n        if (!skipNormalization) {\r\n            base = parse(serialize(base, options), options); //normalize base components\r\n            relative = parse(serialize(relative, options), options); //normalize relative components\r\n        }\r\n        options = options || {};\r\n        if (!options.tolerant && relative.scheme) {\r\n            target.scheme = relative.scheme;\r\n            //target.authority = relative.authority;\r\n            target.userinfo = relative.userinfo;\r\n            target.host = relative.host;\r\n            target.port = relative.port;\r\n            target.path = removeDotSegments(relative.path);\r\n            target.query = relative.query;\r\n        }\r\n        else {\r\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\r\n                //target.authority = relative.authority;\r\n                target.userinfo = relative.userinfo;\r\n                target.host = relative.host;\r\n                target.port = relative.port;\r\n                target.path = removeDotSegments(relative.path);\r\n                target.query = relative.query;\r\n            }\r\n            else {\r\n                if (!relative.path) {\r\n                    target.path = base.path;\r\n                    if (relative.query !== undefined) {\r\n                        target.query = relative.query;\r\n                    }\r\n                    else {\r\n                        target.query = base.query;\r\n                    }\r\n                }\r\n                else {\r\n                    if (relative.path.charAt(0) === \"/\") {\r\n                        target.path = removeDotSegments(relative.path);\r\n                    }\r\n                    else {\r\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\r\n                            target.path = \"/\" + relative.path;\r\n                        }\r\n                        else if (!base.path) {\r\n                            target.path = relative.path;\r\n                        }\r\n                        else {\r\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\r\n                        }\r\n                        target.path = removeDotSegments(target.path);\r\n                    }\r\n                    target.query = relative.query;\r\n                }\r\n                //target.authority = base.authority;\r\n                target.userinfo = base.userinfo;\r\n                target.host = base.host;\r\n                target.port = base.port;\r\n            }\r\n            target.scheme = base.scheme;\r\n        }\r\n        target.fragment = relative.fragment;\r\n        return target;\r\n    }\r\n    ;\r\n    function resolve(baseURI, relativeURI, options) {\r\n        return serialize(resolveComponents(parse(baseURI, options), parse(relativeURI, options), options, true), options);\r\n    }\r\n    ;\r\n    function normalize(uri, options) {\r\n        if (typeof uri === \"string\") {\r\n            uri = serialize(parse(uri, options), options);\r\n        }\r\n        else if (typeOf(uri) === \"object\") {\r\n            uri = parse(serialize(uri, options), options);\r\n        }\r\n        return uri;\r\n    }\r\n    ;\r\n    function equal(uriA, uriB, options) {\r\n        if (typeof uriA === \"string\") {\r\n            uriA = serialize(parse(uriA, options), options);\r\n        }\r\n        else if (typeOf(uriA) === \"object\") {\r\n            uriA = serialize(uriA, options);\r\n        }\r\n        if (typeof uriB === \"string\") {\r\n            uriB = serialize(parse(uriB, options), options);\r\n        }\r\n        else if (typeOf(uriB) === \"object\") {\r\n            uriB = serialize(uriB, options);\r\n        }\r\n        return uriA === uriB;\r\n    }\r\n    ;\r\n    function escapeComponent(str, options) {\r\n        return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\r\n    }\r\n    ;\r\n    function unescapeComponent(str, options) {\r\n        return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\r\n    }\r\n    ;\r\n    return {\r\n        IRI_SUPPORT: URI__IRI_SUPPORT,\r\n        VALIDATE_SUPPORT: URI__VALIDATE_SUPPORT,\r\n        pctEncChar: pctEncChar,\r\n        pctDecChars: pctDecChars,\r\n        SCHEMES: SCHEMES,\r\n        parse: parse,\r\n        _recomposeAuthority: _recomposeAuthority,\r\n        removeDotSegments: removeDotSegments,\r\n        serialize: serialize,\r\n        resolveComponents: resolveComponents,\r\n        resolve: resolve,\r\n        normalize: normalize,\r\n        equal: equal,\r\n        escapeComponent: escapeComponent,\r\n        unescapeComponent: unescapeComponent\r\n    };\r\n})();\r\nif (!COMPILED && typeof module !== \"undefined\" && typeof require === \"function\") {\r\n    var punycode = require(\"./punycode\");\r\n    module.exports = URI;\r\n    require(\"./schemes\");\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/uri.js","import {stringify, parse} from './sf-path';\r\nimport { defaultForm, createDefaults } from './schema-defaults';\r\nimport canonicalTitleMap from './canonical-title-map';\r\n\r\n// export function merge(schema, form, schemaDefaultTypes, ignore, options, readonly, asyncTemplates) {\r\nexport function merge(lookup, form, typeDefaults=createDefaults(), ignore, options, readonly, asyncTemplates) {\r\n  let formItems = [];\r\n  let formItemRest = [];\r\n  form  = form || [];\r\n  let idx = form.indexOf('*');\r\n  options = options || {};\r\n  let stdForm = {};\r\n\r\n  let idxRest = form.indexOf('...');\r\n  if(typeof lookup === 'object' && lookup.hasOwnProperty('properties')) {\r\n    readonly = readonly || lookup.readonly || lookup.readOnly;\r\n    stdForm = defaultForm(lookup, typeDefaults, ignore, options);\r\n\r\n    let defaultFormLookup = stdForm.lookup;\r\n\r\n    lookup = defaultFormLookup || lookup;\r\n    formItems = formItems.concat(stdForm.form);\r\n  };\r\n\r\n  if (idx !== -1) {\r\n    form = form.slice(0, idx).concat(formItems).concat(form.slice(idx + 1));\r\n  }\r\n\r\n  //simple case, we have a \"...\", just put the formItemRest there\r\n  if (stdForm.form && idxRest !== -1) {\r\n    let formKeys = form.map(function(obj) {\r\n      if (typeof obj === 'string'){\r\n        return obj;\r\n      }\r\n      else if (obj.key) {\r\n        return obj.key;\r\n      };\r\n    }).filter(function(element) {\r\n      return element !== undefined;\r\n    });\r\n\r\n    formItemRest = formItemRest.concat(\r\n      stdForm.form.map(function(obj) {\r\n        let isInside = formKeys.indexOf(obj.key[0]) !== -1;\r\n        if (!isInside) {\r\n          return obj;\r\n        };\r\n      })\r\n      .filter(function(element) {\r\n        return element !== undefined;\r\n      })\r\n    );\r\n  };\r\n\r\n  if (idxRest !== -1) {\r\n    form = form.slice(0, idxRest).concat(formItemRest).concat(form.slice(idxRest + 1));\r\n  };\r\n\r\n  // ok let's merge!\r\n  // We look at the supplied form and extend it with schema standards\r\n  return form.map((obj) => {\r\n    // handle the shortcut with just a name\r\n    if (typeof obj === 'string') {\r\n      obj = { key: obj };\r\n    }\r\n\r\n    if (obj.key) {\r\n      if (typeof obj.key === 'string') {\r\n        obj.key = parse(obj.key);\r\n      }\r\n    }\r\n\r\n    // If it has a titleMap make sure it's a list\r\n    if (obj.titleMap) {\r\n      obj.titleMap = canonicalTitleMap(obj.titleMap);\r\n    }\r\n\r\n    // extend with std form from schema.\r\n    if (obj.key) {\r\n      const strid = stringify(obj.key);\r\n      if (lookup[strid]) {\r\n        const schemaDefaults = lookup[strid];\r\n        if (schemaDefaults) {\r\n          Object.keys(schemaDefaults).forEach((attr) => {\r\n            if (obj[attr] === undefined) {\r\n              obj[attr] = schemaDefaults[attr];\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Are we inheriting readonly?\r\n    if (readonly === true) { // Inheriting false is not cool.\r\n      obj.readonly = true;\r\n    }\r\n\r\n    // if it's a type with items, merge 'em!\r\n    if (obj.items) {\r\n      obj.items = merge(lookup, obj.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\r\n    }\r\n\r\n    // if its has tabs, merge them also!\r\n    if (obj.tabs) {\r\n      obj.tabs.forEach((tab) => {\r\n        if (tab.items) {\r\n          tab.items = merge(lookup, tab.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Special case: checkbox\r\n    // Since have to ternary state we need a default\r\n    if (obj.type === 'checkbox') {\r\n      // Check for schema property, as the checkbox may be part of the explicitly defined form\r\n      if (obj.schema === undefined) {\r\n        obj.schema = { default: false };\r\n      }\r\n      else if (obj.schema['default'] === undefined) {\r\n        obj.schema['default'] = false;\r\n      };\r\n    };\r\n\r\n    // Special case: template type with tempplateUrl that's needs to be loaded before rendering\r\n    // TODO: this is not a clean solution. Maybe something cleaner can be made when $ref support\r\n    // is introduced since we need to go async then anyway\r\n    if (asyncTemplates && obj.type === 'template' && !obj.template && obj.templateUrl) {\r\n      asyncTemplates.push(obj);\r\n    };\r\n\r\n    return obj;\r\n  });\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/merge.js","import * as JsonRefs from './../../lib/json-refs-standalone';\r\n\r\nexport function jsonref(schema, callBack) {\r\n  let promise = new Promise(\r\n    function(resolve, reject) {\r\n      JsonRefs.resolveRefs(schema, {\r\n        \"filter\": [ 'relative', 'local', 'remote' ]\r\n      })\r\n        .then((res) => { resolve(res.resolved); })\r\n        .catch((err) => { reject(new Error(err)); });\r\n    }\r\n  );\r\n\r\n  if(typeof(callBack) === 'function') {\r\n    promise\r\n      .then((resolved) => { callBack(null, resolved); })\r\n      .catch((error) => { callBack(error); });\r\n  }\r\n  else {\r\n    return promise;\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/resolve.js","import * as sfPath from './sf-path';\r\n\r\nconst numRe = /^\\d+$/;\r\n\r\n/**\r\n  * @description\r\n  * Utility method to access deep properties without\r\n  * throwing errors when things are not defined.\r\n  * Can also set a value in a deep structure, creating objects when missing\r\n  * ex.\r\n  * var foo = Select('address.contact.name',obj)\r\n  * Select('address.contact.name',obj,'Leeroy')\r\n  *\r\n  * @param {string} projection A dot path to the property you want to get/set\r\n  * @param {object} obj   (optional) The object to project on, defaults to 'this'\r\n  * @param {Any}    valueToSet (opional)  The value to set, if parts of the path of\r\n  *                 the projection is missing empty objects will be created.\r\n  * @returns {Any|undefined} returns the value at the end of the projection path\r\n  *                          or undefined if there is none.\r\n  */\r\nexport function select(projection, obj, valueToSet) {\r\n  if (!obj) {\r\n    obj = this;\r\n  };\r\n\r\n  // Support [] array syntax\r\n  let parts = typeof projection === 'string' ? sfPath.parse(projection) : projection;\r\n\r\n  if (typeof valueToSet !== 'undefined' && parts.length === 1) {\r\n    // special case, just setting one variable\r\n    obj[parts[0]] = valueToSet;\r\n\r\n    return obj;\r\n  };\r\n\r\n  if (typeof valueToSet !== 'undefined' &&\r\n      typeof obj[parts[0]] === 'undefined') {\r\n    // We need to look ahead to check if array is appropriate\r\n    obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {};\r\n  };\r\n\r\n  let value = obj[parts[0]];\r\n\r\n  for (let i = 1; i < parts.length; i++) {\r\n    // Special case: We allow JSON Form syntax for arrays using empty brackets\r\n    // These will of course not work here so we exit if they are found.\r\n    if (parts[i] === '') {\r\n      return undefined;\r\n    };\r\n\r\n    if (typeof valueToSet !== 'undefined') {\r\n      if (i === parts.length - 1) {\r\n        // last step. Let's set the value\r\n        value[parts[i]] = valueToSet;\r\n        return valueToSet;\r\n      }\r\n      else {\r\n        // Make sure to create new objects on the way if they are not there.\r\n        // We need to look ahead to check if array is appropriate\r\n        let tmp = value[parts[i]];\r\n\r\n        if (typeof tmp === 'undefined' || tmp === null) {\r\n          tmp = numRe.test(parts[i + 1]) ? [] : {};\r\n          value[parts[i]] = tmp;\r\n        };\r\n\r\n        value = tmp;\r\n      };\r\n    }\r\n    else if (value) {\r\n      // Just get nex value.\r\n      value = value[parts[i]];\r\n    };\r\n  };\r\n\r\n  return value;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/select.js","/**\r\n * Traverse a schema, applying a function(schema,path) on every sub schema\r\n * i.e. every property of an object.\r\n */\r\nexport function traverseSchema(schema, fn, path, ignoreArrays) {\r\n  ignoreArrays = ignoreArrays === undefined ? true : ignoreArrays;\r\n\r\n  path = path || [];\r\n\r\n  const traverse = function(schemaObject: any, processorFunction: Function, pathArray: Array<string>) {\r\n    processorFunction(schemaObject, pathArray);\r\n    if (schemaObject.properties) {\r\n      Object.keys(schemaObject.properties).forEach((name) => {\r\n        const currentPath = pathArray.slice();\r\n        currentPath.push(name);\r\n        traverse(schemaObject.properties[name], processorFunction, currentPath);\r\n      });\r\n    }\r\n\r\n    // Only support type \"array\" which have a schemaObject as \"items\".\r\n    if (!ignoreArrays && schemaObject.items) {\r\n      const arrPath = pathArray.slice(); arrPath.push('');\r\n      traverse(schemaObject.items, processorFunction, arrPath);\r\n    }\r\n  };\r\n\r\n  traverse(schema, fn, path || []);\r\n}\r\n\r\nexport function traverseForm(form, fn) {\r\n  fn(form);\r\n  if (form.items) {\r\n    form.items.forEach((f) => {\r\n      traverseForm(f, fn);\r\n    });\r\n  }\r\n\r\n  if (form.tabs) {\r\n    form.tabs.forEach((tab) => {\r\n      if (tab.items) {\r\n        tab.items.forEach((f) => {\r\n          traverseForm(f, fn);\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/traverse.js","/*  Common code for validating a value against its form and schema definition */\r\nimport tv4 from 'tv4';\r\n\r\n/**\r\n * Validate a value against its form definition and schema.\r\n * The value should either be of proper type or a string, some type\r\n * coercion is applied.\r\n *\r\n * @param {Object} form A merged form definition, i.e. one with a schema.\r\n * @param {Any} value the value to validate.\r\n * @return {Object} a tv4js result object.\r\n */\r\nexport function validate(form, value) {\r\n  if (!form) {\r\n    return { valid: true };\r\n  };\r\n\r\n  let schema = form.schema;\r\n  if (!schema) {\r\n    return { valid: true };\r\n  };\r\n\r\n  // Input of type text and textareas will give us a viewValue of ''\r\n  // when empty, this is a valid value in a schema and does not count as something\r\n  // that breaks validation of 'required'. But for our own sanity an empty field should\r\n  // not validate if it's required.\r\n  if (value === '') {\r\n    value = undefined;\r\n  };\r\n\r\n  // Numbers fields will give a null value, which also means empty field\r\n  if (form.type === 'number' && value === null) {\r\n    value = undefined;\r\n  };\r\n\r\n  // Version 4 of JSON Schema has the required property not on the\r\n  // property itself but on the wrapping object. Since we like to test\r\n  // only this property we wrap it in a fake object.\r\n  let wrap = { type: 'object', 'properties': {}, required: undefined};\r\n  let propName = form.key[form.key.length - 1];\r\n  wrap.properties[propName] = schema;\r\n\r\n  if (form.required) {\r\n    wrap.required = [ propName ];\r\n  };\r\n\r\n  let valueWrap = {};\r\n  if (!!value) {\r\n    valueWrap[propName] = value;\r\n  };\r\n\r\n  return tv4.validateResult(valueWrap, wrap);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/validate.js","'use strict';\n\n;!function(undefined) {\n\n\tvar ObjectPath = {\n\t\tparse: function(str){\n\t\t\tif(typeof str !== 'string'){\n\t\t\t\tthrow new TypeError('ObjectPath.parse must be passed a string');\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\tvar parts = [];\n\t\t\tvar d, b, q, c;\n\t\t\twhile (i < str.length){\n\t\t\t\td = str.indexOf('.', i);\n\t\t\t\tb = str.indexOf('[', i);\n\n\t\t\t\t// we've reached the end\n\t\t\t\tif (d === -1 && b === -1){\n\t\t\t\t\tparts.push(str.slice(i, str.length));\n\t\t\t\t\ti = str.length;\n\t\t\t\t}\n\n\t\t\t\t// dots\n\t\t\t\telse if (b === -1 || (d !== -1 && d < b)) {\n\t\t\t\t\tparts.push(str.slice(i, d));\n\t\t\t\t\ti = d + 1;\n\t\t\t\t}\n\n\t\t\t\t// brackets\n\t\t\t\telse {\n\t\t\t\t\tif (b > i){\n\t\t\t\t\t\tparts.push(str.slice(i, b));\n\t\t\t\t\t\ti = b;\n\t\t\t\t\t}\n\t\t\t\t\tq = str.slice(b+1, b+2);\n\t\t\t\t\tif (q !== '\"' && q !=='\\'') {\n\t\t\t\t\t\tc = str.indexOf(']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\tparts.push(str.slice(i + 1, c));\n\t\t\t\t\t\ti = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\twhile (str.slice(c - 1, c) === '\\\\' && b < str.length){\n\t\t\t\t\t\t\tb++;\n\t\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts.push(str.slice(i + 2, c).replace(new RegExp('\\\\'+q,'g'), q));\n\t\t\t\t\t\ti = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parts;\n\t\t},\n\n\t\t// root === true : auto calculate root; must be dot-notation friendly\n\t\t// root String : the string to use as root\n\t\tstringify: function(arr, quote){\n\n\t\t\tif(!Array.isArray(arr))\n\t\t\t\tarr = [arr.toString()];\n\n\t\t\tquote = quote === '\"' ? '\"' : '\\'';\n\n\t\t\treturn arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\\\' + quote) + quote + ']'; }).join('');\n\t\t},\n\n\t\tnormalize: function(data, quote){\n\t\t\treturn ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);\n\t\t},\n\n\t\t// Angular\n\t\tregisterModule: function(angular) {\n\t\t\tangular.module('ObjectPath', []).provider('ObjectPath', function(){\n\t\t\t\tthis.parse = ObjectPath.parse;\n\t\t\t\tthis.stringify = ObjectPath.stringify;\n\t\t\t\tthis.normalize = ObjectPath.normalize;\n\t\t\t\tthis.$get = function(){\n\t\t\t\t\treturn ObjectPath;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t};\n\n\t// AMD\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn {ObjectPath: ObjectPath};\n\t\t});\n\t}\n\n\t// CommonJS\n\telse if (typeof exports === 'object') {\n\t\texports.ObjectPath = ObjectPath;\n\t}\n\n\t// Browser global\n\telse {\n\t\twindow.ObjectPath = ObjectPath;\n\t}\n\t\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/lib/ObjectPath.js\n// module id = 11\n// module chunks = 0","module.exports = tv4;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tv4\"\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}