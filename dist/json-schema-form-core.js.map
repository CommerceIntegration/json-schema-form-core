{"version":3,"sources":["webpack:///webpack/bootstrap 425203784fb7a4204298","webpack:///./src/lib/sf-path.ts","webpack:///./src/lib/canonical-title-map.ts","webpack:///./~/objectpath/index.js","webpack:///./src/lib/merge.ts","webpack:///./src/lib/schema-defaults.ts","webpack:///./src/lib/select.ts","webpack:///./src/lib/traverse.ts","webpack:///./src/lib/validate.ts","webpack:///./~/objectpath/lib/ObjectPath.js","webpack:///external \"tv4\"","webpack:///./src/lib/index.ts"],"names":[],"mappings":"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,QAAQ,OAAG,EAAM,MAAU,UAAc,cAAI,IAAU,UAAa;AACpE,QAAY,WAAO,KAAI,IAAK,KAAI,IAAO,SAAM;AACzC,SAAW,WAAU,YAAU;AAEhC,QAAK,KAAU,UAAE;AACd,aAAS,WAAG,CAClB;AAAC;AAAC;AAEF,QAAa,YAAM;AAChB,QAAC,CAAC,CAAO,OAAE;AACH,kBAAU,YACrB;AAAC;AAAC;AAEI,WAAI,4CAAe,eAAU,WACrC;AAAC;AAAC,C;;;;;;;ACpDF;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA;;AAEA,8BAA8B,iGAAiG,EAAE;AACjI,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC,G;;;;;;ACtGD,qB;;;;;;;;;;;;;;;;;;;;;;ACAsD;AAChB;AACkB;AAExB;AACG;AACuB;AACpB;AAE/B,IAAY,SAAa;AACzB,IAAoB,iBAAqB;AACzC,IAAuB,oBAAwB,sE","file":"json-schema-form-core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 425203784fb7a4204298","export { parse } from 'objectpath';\r\nexport { stringify } from 'objectpath';\r\nexport { normalize } from 'objectpath';\r\n\r\n/**\r\n * I am a name formatter function for processing keys into names for classes or Id.\r\n *\r\n * @param  {Array<string>} key         I am the key array of a processed schema key\r\n * @param  {string}        separator   I am the separator between the key items and optional form name\r\n * @param  {string}        formName    I am an optional form name\r\n * @param  {boolean}       omitNumbers I determine if numeric values should be included in the output or withheld\r\n *\r\n * @return {string}                    I am the formatted key\r\n */\r\nexport function name (key: Array<string>, separator?: string, formName = '', omitNumbers = false) {\r\n  if (key) {\r\n    let fieldKey = key.slice();\r\n    let fieldSeparator = separator || '-';\r\n\r\n    if (omitNumbers) {\r\n      fieldKey = fieldKey.filter(function(currentKey: any) {\r\n        return typeof currentKey !== 'number';\r\n      });\r\n    };\r\n\r\n    return ((formName.length !== 0)\r\n      ? formName + fieldSeparator\r\n      : ''\r\n    ) + fieldKey.join(fieldSeparator);\r\n  };\r\n\r\n  return '';\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/sf-path.ts","// Takes a titleMap in either object or list format and returns one\r\n// in the list format.\r\nexport default function(titleMap: Array<any>, originalEnum?: any) {\r\n  if (!Array.isArray(titleMap)) {\r\n    const canonical = [];\r\n    if (originalEnum) {\r\n      originalEnum.forEach((value) => {\r\n        canonical.push({ name: titleMap[value], value });\r\n      });\r\n    } else {\r\n      Object.keys(titleMap).forEach((value) => {\r\n        canonical.push({ name: titleMap[value], value });\r\n      });\r\n    }\r\n    return canonical;\r\n  }\r\n  return titleMap;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/canonical-title-map.ts","module.exports = require('./lib/ObjectPath.js').ObjectPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/index.js\n// module id = 2\n// module chunks = 0","import {stringify, parse} from './sf-path';\r\nimport canonicalTitleMap from './canonical-title-map';\r\n\r\n// export function merge(schema, form, schemaDefaultTypes, ignore, options, readonly, asyncTemplates) {\r\nexport function merge(lookup, form, options, readonly, asyncTemplates) {\r\n  form  = form || [];\r\n  options = options || {};\r\n\r\n  // ok let's merge!\r\n  // We look at the supplied form and extend it with schema standards\r\n  return form.map((obj) => {\r\n\r\n    // handle the shortcut with just a name\r\n    if (typeof obj === 'string') {\r\n      obj = { key: obj };\r\n    }\r\n\r\n    if (obj.key) {\r\n      if (typeof obj.key === 'string') {\r\n        obj.key = parse(obj.key);\r\n      }\r\n    }\r\n\r\n    // If it has a titleMap make sure it's a list\r\n    if (obj.titleMap) {\r\n      obj.titleMap = canonicalTitleMap(obj.titleMap);\r\n    }\r\n\r\n    // extend with std form from schema.\r\n    if (obj.key) {\r\n      const strid = stringify(obj.key);\r\n      if (lookup[strid]) {\r\n        const schemaDefaults = lookup[strid];\r\n        if (schemaDefaults) {\r\n          Object.keys(schemaDefaults).forEach((attr) => {\r\n            if (obj[attr] === undefined) {\r\n              obj[attr] = schemaDefaults[attr];\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Are we inheriting readonly?\r\n    if (readonly === true) { // Inheriting false is not cool.\r\n      obj.readonly = true;\r\n    }\r\n\r\n    // if it's a type with items, merge 'em!\r\n    if (obj.items) {\r\n      obj.items = merge(lookup, obj.items, options, obj.readonly, asyncTemplates);\r\n    }\r\n\r\n    // if its has tabs, merge them also!\r\n    if (obj.tabs) {\r\n      obj.tabs.forEach((tab) => {\r\n        if (tab.items) {\r\n          tab.items = merge(lookup, tab.items, options, obj.readonly, asyncTemplates);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Special case: checkbox\r\n    // Since have to ternary state we need a default\r\n    if (obj.type === 'checkbox' && obj.schema['default'] === undefined) {\r\n      obj.schema['default'] = false;\r\n    };\r\n\r\n    // Special case: template type with tempplateUrl that's needs to be loaded before rendering\r\n    // TODO: this is not a clean solution. Maybe something cleaner can be made when $ref support\r\n    // is introduced since we need to go async then anyway\r\n    if (asyncTemplates && obj.type === 'template' && !obj.template && obj.templateUrl) {\r\n      asyncTemplates.push(obj);\r\n    }\r\n\r\n    return obj;\r\n  });\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/merge.ts","import { stringify } from './sf-path';\r\nimport canonicalTitleMap from './canonical-title-map';\n\r\n/* Utils */\r\nconst stripNullType = (type) => {\r\n  if (Array.isArray(type) && type.length === 2) {\r\n    if (type[0] === 'null') {\r\n      return type[1];\n    };\r\n    if (type[1] === 'null') {\r\n      return type[0];\n    };\r\n  };\r\n  return type;\r\n};\r\n\r\n// Creates an default titleMap list from an enum, i.e. a list of strings.\r\nconst enumToTitleMap = (enm) => {\r\n  const titleMap = []; // canonical titleMap format is a list.\r\n  enm.forEach((name) => {\r\n    titleMap.push({ name, value: name });\r\n  });\r\n  return titleMap;\r\n};\r\n\r\n/**\r\n * Creates a default form definition from a schema.\r\n */\r\nexport function defaultFormDefinition(schemaTypes, name, schema, options) {\r\n  const rules = schemaTypes[stripNullType(schema.type)];\r\n  if (rules) {\r\n    let def;\r\n    // We give each rule a possibility to recurse it's children.\r\n    const innerDefaultFormDefinition = (childName, childSchema , childOptions) =>\r\n                          defaultFormDefinition(schemaTypes, childName, childSchema, childOptions);\r\n    for (let i = 0; i < rules.length; i++) {\r\n      def = rules[i](name, schema, options, innerDefaultFormDefinition);\r\n\r\n      // first handler in list that actually returns something is our handler!\r\n      if (def) {\r\n\r\n        // Do we have form defaults in the schema under the x-schema-form-attribute?\r\n        if (def.schema['x-schema-form']) {\r\n          Object.assign(def, def.schema['x-schema-form']);\r\n        }\r\n\r\n        return def;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a form object with all common properties\r\n */\r\nexport function stdFormObj(name, schema, options) {\r\n  options = options || {};\r\n\r\n  // The Object.assign used to be a angular.copy. Should work though.\r\n  const f = options.global && options.global.formDefaults ?\r\n          Object.assign({}, options.global.formDefaults) : {};\r\n  if (options.global && options.global.supressPropertyTitles === true) {\r\n    f.title = schema.title;\r\n  } else {\r\n    f.title = schema.title || name;\r\n  }\r\n\r\n  if (schema.description) { f.description = schema.description; }\r\n  if (options.required === true || schema.required === true) { f.required = true; }\r\n  if (schema.maxLength) { f.maxlength = schema.maxLength; }\r\n  if (schema.minLength) { f.minlength = schema.minLength; }\r\n  if (schema.readOnly || schema.readonly) { f.readonly  = true; }\r\n  if (schema.minimum) { f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0); }\r\n  if (schema.maximum) { f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0); }\r\n\r\n  // Non standard attributes (DONT USE DEPRECATED)\r\n  // If you must set stuff like this in the schema use the x-schema-form attribute\r\n  if (schema.validationMessage) { f.validationMessage = schema.validationMessage; }\r\n  if (schema.enumNames) { f.titleMap = canonicalTitleMap(schema.enumNames, schema['enum']); }\r\n  f.schema = schema;\r\n\r\n  // Ng model options doesn't play nice with undefined, might be defined\r\n  // globally though\r\n  f.ngModelOptions = f.ngModelOptions || {};\r\n\r\n  return f;\r\n};\r\n\r\n/*** Schema types to form type mappings, with defaults ***/\r\nexport function text(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'string' && !schema['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'text';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\n// default in json form for number and integer is a text field\r\n// input type=\"number\" would be more suitable don't ya think?\r\nexport function number(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'number') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'number';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function integer(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'integer') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'number';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function checkbox(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'boolean') {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'checkbox';\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function select(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'string' && schema['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'select';\r\n    if (!f.titleMap) {\r\n      f.titleMap = enumToTitleMap(schema['enum']);\r\n    }\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function checkboxes(name, schema, options) {\r\n  if (stripNullType(schema.type) === 'array' && schema.items && schema.items['enum']) {\r\n    const f = stdFormObj(name, schema, options);\r\n    f.key  = options.path;\r\n    f.type = 'checkboxes';\r\n    if (!f.titleMap) {\r\n      f.titleMap = enumToTitleMap(schema.items['enum']);\r\n    }\r\n    options.lookup[stringify(options.path)] = f;\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function fieldset(name, schema, options, defaultFormDef) {\r\n  if (stripNullType(schema.type) === 'object') {\r\n    const f   = stdFormObj(name, schema, options);\r\n    f.type  = 'fieldset';\r\n    f.key   = options.path;\r\n    f.items = [];\r\n    options.lookup[stringify(options.path)] = f;\r\n\r\n    // recurse down into properties\r\n    if (schema.properties) {\r\n      Object.keys(schema.properties).forEach((key) => {\r\n        const value = schema.properties[key];\r\n        const path = options.path.slice();\r\n        path.push(key);\r\n        if (options.ignore[stringify(path)] !== true) {\r\n          const required = schema.required && schema.required.indexOf(key) !== -1;\r\n\r\n          const def = defaultFormDef(key, value, {\r\n            path,\r\n            required: required || false,\r\n            lookup: options.lookup,\r\n            ignore: options.ignore,\r\n            global: options.global\r\n          });\r\n          if (def) {\r\n            f.items.push(def);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function array(name, schema, options, defaultFormDef) {\r\n  if (stripNullType(schema.type) === 'array') {\r\n    const f   = stdFormObj(name, schema, options);\r\n    f.type  = 'array';\r\n    f.key   = options.path;\r\n    options.lookup[stringify(options.path)] = f;\r\n\r\n    const required = schema.required &&\r\n                   schema.required.indexOf(options.path[options.path.length - 1]) !== -1;\r\n\r\n    // The default is to always just create one child. This works since if the\r\n    // schemas items declaration is of type: \"object\" then we get a fieldset.\r\n    // We also follow json form notatation, adding empty brackets \"[]\" to\r\n    // signify arrays.\r\n\r\n    const arrPath = options.path.slice();\r\n    arrPath.push('');\r\n\r\n    f.items = [\n      defaultFormDef(name, schema.items, {\r\n        path: arrPath,\r\n        required: required || false,\r\n        lookup: options.lookup,\r\n        ignore: options.ignore,\r\n        global: options.global\r\n      })\n    ];\r\n\r\n    return f;\r\n  }\r\n}\r\n\r\nexport function createDefaults() {\r\n  // First sorted by schema type then a list.\r\n  // Order has importance. First handler returning an form snippet will be used.\r\n  return {\r\n    string:  [ select, text ],\r\n    object:  [ fieldset ],\r\n    number:  [ number ],\r\n    integer: [ integer ],\r\n    boolean: [ checkbox ],\r\n    array:   [ checkboxes, array ]\r\n  };\r\n};\r\n\r\n/**\r\n * Create form defaults from schema\r\n */\r\nexport function defaultForm(schema: any, defaultSchemaTypes: any, ignore?: any, globalOptions?: any) {\r\n  const form   = [];\r\n  const lookup = {}; // Map path => form obj for fast lookup in merging\r\n  ignore = ignore || {};\r\n  globalOptions = globalOptions || {};\r\n  defaultSchemaTypes = defaultSchemaTypes || createDefaults();\r\n\r\n  if (schema.properties) {\r\n    Object.keys(schema.properties).forEach((key) => {\r\n      if (ignore[key] !== true) {\r\n        const required = schema.required && schema.required.indexOf(key) !== -1;\r\n        const def = defaultFormDefinition(defaultSchemaTypes, key, schema.properties[key], {\r\n          path: [ key ],         // Path to this property in bracket notation.\r\n          lookup: lookup,    // Extra map to register with. Optimization for merger.\r\n          ignore: ignore,    // The ignore list of paths (sans root level name)\r\n          required: required, // Is it required? (v4 json schema style)\r\n          global: globalOptions // Global options, including form defaults\r\n        });\r\n        if (def) {\r\n          form.push(def);\r\n        }\r\n      }\r\n    });\r\n  }\n  else {\r\n    throw new Error('Not implemented. Only type \"object\" allowed at root level of schema.');\r\n  }\r\n  return { form: form, lookup: lookup };\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/schema-defaults.ts","import * as sfPath from './sf-path';\r\n\r\nconst numRe = /^\\d+$/;\r\n\r\n/**\r\n  * @description\r\n  * Utility method to access deep properties without\r\n  * throwing errors when things are not defined.\r\n  * Can also set a value in a deep structure, creating objects when missing\r\n  * ex.\r\n  * var foo = Select('address.contact.name',obj)\r\n  * Select('address.contact.name',obj,'Leeroy')\r\n  *\r\n  * @param {string} projection A dot path to the property you want to get/set\r\n  * @param {object} obj   (optional) The object to project on, defaults to 'this'\r\n  * @param {Any}    valueToSet (opional)  The value to set, if parts of the path of\r\n  *                 the projection is missing empty objects will be created.\r\n  * @returns {Any|undefined} returns the value at the end of the projection path\r\n  *                          or undefined if there is none.\r\n  */\r\nexport function select(projection, obj, valueToSet) {\r\n  if (!obj) {\r\n    obj = this;\r\n  };\r\n\r\n  // Support [] array syntax\r\n  let parts = typeof projection === 'string' ? sfPath.parse(projection) : projection;\r\n\r\n  if (typeof valueToSet !== 'undefined' && parts.length === 1) {\r\n    // special case, just setting one variable\r\n    obj[parts[0]] = valueToSet;\r\n    return obj;\r\n  };\r\n\r\n  if (typeof valueToSet !== 'undefined' &&\r\n      typeof obj[parts[0]] === 'undefined') {\r\n    // We need to look ahead to check if array is appropriate\r\n    obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {};\r\n  };\r\n\r\n  let value = obj[parts[0]];\r\n  for (let i = 1; i < parts.length; i++) {\r\n    // Special case: We allow JSON Form syntax for arrays using empty brackets\r\n    // These will of course not work here so we exit if they are found.\r\n    if (parts[i] === '') {\r\n      return undefined;\r\n    }\r\n    if (typeof valueToSet !== 'undefined') {\r\n      if (i === parts.length - 1) {\r\n        // last step. Let's set the value\r\n        value[parts[i]] = valueToSet;\r\n        return valueToSet;\r\n      } else {\r\n        // Make sure to create new objects on the way if they are not there.\r\n        // We need to look ahead to check if array is appropriate\r\n        let tmp = value[parts[i]];\r\n        if (typeof tmp === 'undefined' || tmp === null) {\r\n          tmp = numRe.test(parts[i + 1]) ? [] : {};\r\n          value[parts[i]] = tmp;\r\n        }\r\n        value = tmp;\r\n      }\r\n    } else if (value) {\r\n      // Just get nex value.\r\n      value = value[parts[i]];\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/select.ts","/**\r\n * Traverse a schema, applying a function(schema,path) on every sub schema\r\n * i.e. every property of an object.\r\n */\r\nexport function traverseSchema(schema, fn, path, ignoreArrays) {\r\n  ignoreArrays = ignoreArrays === undefined ? true : ignoreArrays;\r\n\r\n  path = path || [];\r\n\r\n  const traverse = function(schemaObject: any, processorFunction: Function, pathArray: Array<string>) {\r\n    processorFunction(schemaObject, pathArray);\r\n    if (schemaObject.properties) {\r\n      Object.keys(schemaObject.properties).forEach((name) => {\r\n        const currentPath = pathArray.slice();\r\n        currentPath.push(name);\r\n        traverse(schemaObject.properties[name], processorFunction, currentPath);\r\n      });\r\n    }\r\n\r\n    // Only support type \"array\" which have a schemaObject as \"items\".\r\n    if (!ignoreArrays && schemaObject.items) {\r\n      const arrPath = pathArray.slice(); arrPath.push('');\r\n      traverse(schemaObject.items, processorFunction, arrPath);\r\n    }\r\n  };\r\n\r\n  traverse(schema, fn, path || []);\r\n}\r\n\r\nexport function traverseForm(form, fn) {\r\n  fn(form);\r\n  if (form.items) {\r\n    form.items.forEach((f) => {\r\n      traverseForm(f, fn);\r\n    });\r\n  }\r\n\r\n  if (form.tabs) {\r\n    form.tabs.forEach((tab) => {\r\n      if (tab.items) {\r\n        tab.items.forEach((f) => {\r\n          traverseForm(f, fn);\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/traverse.ts","/*  Common code for validating a value against its form and schema definition */\r\nimport tv4 from 'tv4';\r\n\r\n/**\r\n * Validate a value against its form definition and schema.\r\n * The value should either be of proper type or a string, some type\r\n * coercion is applied.\r\n *\r\n * @param {Object} form A merged form definition, i.e. one with a schema.\r\n * @param {Any} value the value to validate.\r\n * @return {Object} a tv4js result object.\r\n */\r\nexport function validate(form, value) {\r\n  if (!form) {\r\n    return { valid: true };\r\n  };\r\n\r\n  let schema = form.schema;\r\n  if (!schema) {\r\n    return { valid: true };\r\n  };\r\n\r\n  // Input of type text and textareas will give us a viewValue of ''\r\n  // when empty, this is a valid value in a schema and does not count as something\r\n  // that breaks validation of 'required'. But for our own sanity an empty field should\r\n  // not validate if it's required.\r\n  if (value === '') {\r\n    value = undefined;\r\n  };\r\n\r\n  // Numbers fields will give a null value, which also means empty field\r\n  if (form.type === 'number' && value === null) {\r\n    value = undefined;\r\n  };\r\n\r\n  // Version 4 of JSON Schema has the required property not on the\r\n  // property itself but on the wrapping object. Since we like to test\r\n  // only this property we wrap it in a fake object.\r\n  let wrap = { type: 'object', 'properties': {}, required: undefined};\r\n  let propName = form.key[form.key.length - 1];\r\n  wrap.properties[propName] = schema;\r\n\r\n  if (form.required) {\r\n    wrap.required = [ propName ];\r\n  };\r\n\r\n  let valueWrap = {};\r\n  if (!!value) {\r\n    valueWrap[propName] = value;\r\n  };\r\n\r\n  return tv4.validateResult(valueWrap, wrap);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/validate.ts","'use strict';\n\n;!function(undefined) {\n\n\tvar ObjectPath = {\n\t\tparse: function(str){\n\t\t\tif(typeof str !== 'string'){\n\t\t\t\tthrow new TypeError('ObjectPath.parse must be passed a string');\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\tvar parts = [];\n\t\t\tvar d, b, q, c;\n\t\t\twhile (i < str.length){\n\t\t\t\td = str.indexOf('.', i);\n\t\t\t\tb = str.indexOf('[', i);\n\n\t\t\t\t// we've reached the end\n\t\t\t\tif (d === -1 && b === -1){\n\t\t\t\t\tparts.push(str.slice(i, str.length));\n\t\t\t\t\ti = str.length;\n\t\t\t\t}\n\n\t\t\t\t// dots\n\t\t\t\telse if (b === -1 || (d !== -1 && d < b)) {\n\t\t\t\t\tparts.push(str.slice(i, d));\n\t\t\t\t\ti = d + 1;\n\t\t\t\t}\n\n\t\t\t\t// brackets\n\t\t\t\telse {\n\t\t\t\t\tif (b > i){\n\t\t\t\t\t\tparts.push(str.slice(i, b));\n\t\t\t\t\t\ti = b;\n\t\t\t\t\t}\n\t\t\t\t\tq = str.slice(b+1, b+2);\n\t\t\t\t\tif (q !== '\"' && q !=='\\'') {\n\t\t\t\t\t\tc = str.indexOf(']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\tparts.push(str.slice(i + 1, c));\n\t\t\t\t\t\ti = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\twhile (str.slice(c - 1, c) === '\\\\' && b < str.length){\n\t\t\t\t\t\t\tb++;\n\t\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts.push(str.slice(i + 2, c).replace(new RegExp('\\\\'+q,'g'), q));\n\t\t\t\t\t\ti = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parts;\n\t\t},\n\n\t\t// root === true : auto calculate root; must be dot-notation friendly\n\t\t// root String : the string to use as root\n\t\tstringify: function(arr, quote){\n\n\t\t\tif(!Array.isArray(arr))\n\t\t\t\tarr = [arr.toString()];\n\n\t\t\tquote = quote === '\"' ? '\"' : '\\'';\n\n\t\t\treturn arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\\\' + quote) + quote + ']'; }).join('');\n\t\t},\n\n\t\tnormalize: function(data, quote){\n\t\t\treturn ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);\n\t\t},\n\n\t\t// Angular\n\t\tregisterModule: function(angular) {\n\t\t\tangular.module('ObjectPath', []).provider('ObjectPath', function(){\n\t\t\t\tthis.parse = ObjectPath.parse;\n\t\t\t\tthis.stringify = ObjectPath.stringify;\n\t\t\t\tthis.normalize = ObjectPath.normalize;\n\t\t\t\tthis.$get = function(){\n\t\t\t\t\treturn ObjectPath;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t};\n\n\t// AMD\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn {ObjectPath: ObjectPath};\n\t\t});\n\t}\n\n\t// CommonJS\n\telse if (typeof exports === 'object') {\n\t\texports.ObjectPath = ObjectPath;\n\t}\n\n\t// Browser global\n\telse {\n\t\twindow.ObjectPath = ObjectPath;\n\t}\n\t\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/lib/ObjectPath.js\n// module id = 8\n// module chunks = 0","module.exports = tv4;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tv4\"\n// module id = 9\n// module chunks = 0","import * as schemaDefaultsImp from './schema-defaults';\r\nimport * as sfPathImp from './sf-path';\r\nimport canonicalTitleMapImp from './canonical-title-map';\r\n\r\nexport { merge } from './merge';\r\nexport { select }  from './select';\r\nexport { traverseSchema, traverseForm } from './traverse';\r\nexport { validate } from './validate';\r\n\r\nexport const sfPath = sfPathImp;\r\nexport const schemaDefaults = schemaDefaultsImp;\r\nexport const canonicalTitleMap = canonicalTitleMapImp;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/index.ts"],"sourceRoot":""}